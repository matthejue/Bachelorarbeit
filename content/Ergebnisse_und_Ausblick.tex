%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
\chapter{Ergebnisse und Ausblick}
\label{ch:ergebnisse_und_ausblick}

  % https://www.overleaf.com/learn/latex/Counters
\setcounter{defcounter}{1}
\counterwithin{defcounter}{chapter}

newtotcounter{tmpprim}

\section{Funktionsumfang}
\section{Qualitätssicherung}
% GCC + Execution entspricht einem einzigen großen Interpreter und beweist somit den linke Edge in 2.1
\label{sec:qualitätssicherung}
% RETI-Interpreter erwähnen
% TODO: zusammenfassendes Bild
\section{Kommentierter Kompiliervorgang}
\section{Erweiterungsideen}
Sollte tatsächlich eines Tages eine \colorbold{RETI-CPU} auf einem \colorbold{FPGA} implementiert werden, sodass ein \colorbold{provisorisches Betriebssystem} darauf laufen könnte, dann wäre der nächste Schritt einen PicoC-Compiler zu schreiben, der in der Programmiersprache $L_{PicoC}$ selbst geschrieben ist und sich selbst kompilieren kann. Je nach Implementierungsart dieses \colorbold{Self-compiling Compiler} kann dadurch \colorbold{Unabhängigkeit} von der Programmiersprache \colorbold{Python}, in der der momentane Compiler $C_{PicoC}$ für $L_{PicoC}$ momentan implementiert ist und Unabhängigkeit von einer anderen Maschiene, die bisher immer für das \colorbold{Cross-Compiling} notwendig war erreicht werden.

Will man nun für eine Maschiene $M_{RETI}$, auf der keine anderen Programmiersprachen mittels \colorbold{Bootstrapping} zum laufen gebracht wurden den gerade beschriebenen \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ implementieren und hat bereits den gesamtem \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ in der Sprache  $L_{PicoC}$ geschrieben, so stösst man auf ein Problem, dass auf das \colorbold{Henne-Ei-Problem}\footnote{Beschreibt die Situation, wenn ein System sich selbst als \colorbold{Abhängigkeit} hat, damit es überhaupt einen \colorbold{Anfang} für dieses System geben kann. Dafür steht das Problem mit der \colorbold{Henne} und dem \colorbold{Ei} sinnbildlich, da hier die Frage ist, wie das ganze seinen Anfang genommen hat, da beides \colorbold{zirkular} voneinander abhängt.} reduziert werden kann. Man bräuchte, um den \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ auf der \colorbold{Maschiene} $M_{RETI}$ zu kompilieren bereits einen kompilierten \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$, der mit der Maschienensprache \colorbold{RETI} läuft. Es liegt eine \colorbold{zirkulare Abhängigkeit vor}, die man nur auflösen kann, indem eine \colorbold{externe Entität} zur Hilfe nimmt.

Da man den gesamten \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ nicht selbst komplett in der Maschienensprache \colorbold{RETI} schreiben will, wäre eine Möglichkeit, dass man den \colorbold{Cross-Compiler} $C_{PicoC\_PicoC}$, den man bereits in der Programmiersprache \colorbold{Python} implementiert hat, der in diesem Fall die \colorbold{externe Entität} darstellt, auf einer anderen Maschiene $M$ dafür nutzt, damit dieser den \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ für die Maschiene $M_{RETI}$ kompiliert bzw. \colorbold{bootstraped} (Definition~\nameref{par:bootstrapping1}) und man den kompilierten \colorbold{RETI-Maschiendencode} dann einfach auf die Maschiene $M_{RETI}$ kopiert.\footnote{Im Fall, dass auf der Maschiene $M_{RETI}$ die Programmiersprache $L_{Python}$ bereits mittels \colorbold{Bootstrapping} zum Laufen gebracht wurde, könnte der \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$ auch mithife des \colorbold{Cross-Compilers} $C_{PicoC\_Python}$ als \colorbold{externe Entität} und der Programmiersprache \colorbold{Python} auf der Maschiene $M_{RETI}$ selbst kompiliert werden.}

Aufbauend auf dem \colorbold{Self-compiling Compiler} $C_{PicoC\_PicoC}$, der einen \colorbold{minimalen Compiler} für die \colorbold{Programmiersprache} $C$, $L_C$ darstellt, könnte man auch die komplette Sprache $L_C$ für die Maschiene $M_{FPGA}$ ebenfalls mittels \colorbold{Bootstrapping} (Defintion~\nameref{par:bootstrapping2}) implementieren.

So ist eine mögliche Lösung, um diesen \colorbold{Compiler} $C_w$ zu erhalten, in einem ersten Schritt einen \colorbold{minimalen Compiler} $C_{w_{min}}$ zu schreiben, der eine reduzierte \colorbold{Wunschsprache} $L_{w_{min}}$ in die \colorbold{Maschienensprache} $B_2$ der Zielmaschine $M_2$ kompiliert.

Diesen \colorbold{minimalen Compiler} $C_{w_{min}}$ könnte man nun auf dem aufwendigen Weg komplett in der \colorbold{Assemblersprache} $A_2$ (Definition~\ref{def:assemblersprache}) der \colorbold{Maschienensprache} $B_2$ schreiben. Oder man verwendet einen anderen Compiler $C_o$, der eine Sprache $L_o$ kompiliert und schreibt diesen \colorbold{minimalen Compiler} $C_{w_{min}}$ in dieser Sprache $L_o$ und kompiliert diesen dann mit dem Compiler $C_o$. Dieser andere Compiler $C_o$ kann entweder ein \colorbold{Cross-Compiler} sein, der auf einer anderen Maschine $M_1$ läuft oder ein Compiler, der bereits auf der Zielmaschine $M_2$ mittels \colorbold{Bootstrapping} (Definition~\ref{def:bootstrapping}) zum laufen gebracht wurde.

Hat man diesen \colorbold{minimalen Compiler} $C_{w_{min}}$, kann man Programme in der Wunschsprache schreiben und mithilfe des \colorbold{minimalen Compilers} kompilieren, sodass diese Programme auf der Zielmaschine laufen.

Nun kann man den \colorbold{minimalen Compiler} $C_{w_{min}}$, den man gerade eben in einer \colorbold{Programmiersprache} $L_o$ implementiert hat, in der \colorbold{Wunschsprache} $L_w$ selbst implementieren und dann mit dem \colorbold{minamlen Compiler} für ebendiese Wunschsprache selbst kompilieren. Was man als Output bekommt ist ein \colorbold{minimmaler Compiler}, der aber auf der \colorbold{Zielmaschine} läuft und die \colorbold{Wunschsprache} in die \colorbold{Maschienensprache} der Zielmaschine kompiliert.

Aufbauend auf diesem \colorbold{minimalen Compiler}, der auf der \colorbold{Zielmaschine} läuft, kann man nun auf der Zielmaschine selbst \colorbold{iterativ} den minimalen Compiler schrittweise zu einem umfangreicheren Compiler, der mehr Funktionalitäten unterstützt weiterentwickeln und braucht die ursprüngliche Maschine, auf dem man die allererste Version des minimalen Compilers implementiert hat nicht mehr. Dieses Vorgehen wird auch als \colorbold{Bootstrapping} (Definition~\ref{def:bootstrapping}) bezeichnet.\footnote{Der Begriff hat seinen Ursprung in der englischen Redewendung \glqq pulling yourself up by your own bootstraps\grqq, was im deutschen ungefähr der aus den Lügengeschichten des Freiherrn von Münchhausen bekannten Redewendung \glqq sich am eigenen Schopf aus dem Sumpf ziehen\grqq entspricht.}

\begin{Definition}{Bootstrapping}{bootstrapping}
  Es gibt zwei verschiedene Formen von \colorbold{Bootstrapping}:

  % https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
  \titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0mm}{}[:]

  % https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
  \paragraph{\thedefcounter{.1}}\label{par:bootstrapping1}\hspace{-0.25cm}
  Wenn man einen \colorbold{Compiler} $C_w$ für eine Wunschsprache $L_w$, der auf einer \colorbold{Maschine} $M_1$ läuft, auch auf einer \colorbold{Zielmaschine} $M_2$ zum laufen bringt, wobei der \colorbold{Compiler} $C_w$ selbst in der Sprache $L_w$ geschrieben ist, die er selbst kompiliert.

  \paragraph{\thedefcounter{.2}}\label{par:bootstrapping2}\hspace{-0.25cm}
  Wenn man die akutelle Version eines Compiler $C_{w_i}$ für die momentane Version einer Wunschsprache $L_{w_i}$ mithilfe von \colorbold{früheren Versionen} seiner selbst schreibt. Man schreibt den erweiterten Compiler in der Sprache $L_{w_{i-1}}$, welche von der früheren Version des Compilers, $C_{w_{i-1}}$ kompiliert wird und schafft es so iterativ immer umfangreichere Compiler zu bauen.\footcite{earley_formalism_1970}\footnote{Der Begriff ist sinnverwandt mit dem \colorbold{Booten} eines Computers, wo die wichtigste Software, der \colorbold{Kernel} zuerst in den Speicher geladen wird und darauf aufbauend von diesem dann das Betriebssysteme, welches bei Bedarf dann \colorbold{Systemsoftware}, Software, die das Ausführen von Anwendungssoftware ermöglicht oder unterstützt, wie z.B. Treiber. und \colorbold{Anwendungssoftware}, Software, deren Anwendung darin besteht, dass sie dem Benutzer unmittelbar eine Dienstleistung zur Verfügung stellt, lädt.}
\end{Definition}

Definition~\nameref{par:bootstrapping1}
Definition~\nameref{par:bootstrapping2}
Definition~\nameref{par:bootstrapping1}
Definition~\nameref{par:bootstrapping2}
