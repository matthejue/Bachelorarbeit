%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
\chapter{Ergebnisse und Ausblick}
\label{ch:ergebnisse_und_ausblick}

  % https://www.overleaf.com/learn/latex/Counters
\counterwithin{defcounter}{chapter}

\section{Funktionsumfang}
\section{Qualitätssicherung}
% GCC + Execution entspricht einem einzigen großen Interpreter und beweist somit den linke Edge in 2.1
\label{sec:qualitätssicherung}
% RETI-Interpreter erwähnen
% TODO: zusammenfassendes Bild
\section{Kommentierter Kompiliervorgang}
\section{Erweiterungsideen}
Wenn eines Tages eine \colorbold{RETI-CPU} auf einem \colorbold{FPGA} implementiert werden sollte, sodass ein \colorbold{provisorisches Betriebssystem} darauf laufen könnte, dann wäre der nächste Schritt einen \colorbold{Self-Compiling Compiler} $C_{PicoC}^{PicoC}$ (Defintion~\ref{def:self_compiling_compiler}) zu schreiben, der selbst in der Programmiersprache $L_{PicoC}$ geschrieben ist und sich selbst kompilieren kann. Je nach Implementierungsart dieses \colorbold{Self-compiling Compiler} kann dadurch \colorbold{Unabhängigkeit} von der Programmiersprache \colorbold{Python}, in der der momentane Compiler $C_{PicoC}$ für $L_{PicoC}$ momentan implementiert ist und Unabhängigkeit von einer anderen Maschiene, die bisher immer für das \colorbold{Cross-Compiling} notwendig war erreicht werden.

\begin{Definition}{Self-compiling Compiler}{self_compiling_compiler}
  Compiler $C_w^w$, der in der Sprache $L_w$ \colorbold{geschrieben} ist, die er \colorbold{selbst} kompiliert. Also ein Compiler, der sich \colorbold{selbst} kompilieren könnte.
\end{Definition}

Will man nun für eine Maschiene $M_{RETI}$, auf der bisher keine anderen Programmiersprachen mittels \colorbold{Bootstrapping} (Definition~\ref{def:bootstrapping}) zum laufen gebracht wurden, den gerade beschriebenen \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ implementieren und hat bereits den gesamtem \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ in der Sprache  $L_{PicoC}$ geschrieben, so stösst man auf ein Problem, dass auf das \colorbold{Henne-Ei-Problem}\footnote{Beschreibt die Situation, wenn ein System sich selbst als \colorbold{Abhängigkeit} hat, damit es überhaupt einen \colorbold{Anfang} für dieses System geben kann. Dafür steht das Problem mit der \colorbold{Henne} und dem \colorbold{Ei} sinnbildlich, da hier die Frage ist, wie das ganze seinen Anfang genommen hat, da beides \colorbold{zirkular} voneinander abhängt.} reduziert werden kann. Man bräuchte, um den \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ auf der \colorbold{Maschiene} $M_{RETI}$ zu kompilieren bereits einen kompilierten \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$, der mit der Maschienensprache \colorbold{RETI} läuft. Es liegt eine \colorbold{zirkulare Abhängigkeit} vor, die man nur auflösen kann, indem eine \colorbold{externe Entität} zur Hilfe nimmt.

Da man den gesamten \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ nicht selbst komplett in der Maschienensprache \colorbold{RETI} schreiben will, wäre eine Möglichkeit, dass man den \colorbold{Cross-Compiler} $C_{PicoC}^{Python}$, den man bereits in der Programmiersprache \colorbold{Python} implementiert hat, der in diesem Fall die \colorbold{externe Entität} darstellt, auf einer anderen Maschiene $M$ dafür nutzt, damit dieser den \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ für die Maschiene $M_{RETI}$ kompiliert bzw. \colorbold{bootstraped} und man den kompilierten \colorbold{RETI-Maschiendencode} dann einfach auf die Maschiene $M_{RETI}$ kopiert.\footnote{Im Fall, dass auf der Maschiene $M_{RETI}$ die Programmiersprache $L_{Python}$ bereits mittels \colorbold{Bootstrapping} zum Laufen gebracht wurde, könnte der \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$ auch mithife des \colorbold{Cross-Compilers} $C_{PicoC}^{Python}$ als \colorbold{externe Entität} und der Programmiersprache \colorbold{Python} auf der Maschiene $M_{RETI}$ selbst kompiliert werden.}

Aufbauend auf dem \colorbold{Self-compiling Compiler} $C_{PicoC}^{PicoC}$, der einen \colorbold{minimalen Compiler} (Definition~\ref{def:minimaler_compiler}) für eine Teilmenge der \colorbold{Programmiersprache} C bzw. $L_C$ darstellt, könnte man auch noch die komplette Sprache $L_C$ für die Maschiene $M_{RETI}$ mittels \colorbold{Bootstrapping} (Defintion~\nameref{par:bootstrapping}) implementieren.\footnote{Natürlich könnte man aber auch einfach den \colorbold{Cross-Compiler} $C_{PicoC}^{Python}$ um weitere Funktionalitäten von $L_C$ erweitern, hat dann aber weiterhin eine \colorbold{Abhängigkeit} von der Programmiersprache \colorbold{Python}.}

\begin{Special_Paragraph}
  Einen ersten \colorbold{minimalen Compiler} $C_{2\_min}$ für eine Maschiene $M_2$, kann man entweder mittels eines \colorbold{externen} \colorbold{Bootstrap Compilers} (Definition~\ref{def:bootstrap_compiler}) $C_o$ kompilieren\footnote{In diesem Fall, dem \colorbold{Cross-Compiler} $C_{PicoC}^{Python}$.} oder man schreibt in direkt in der \colorbold{Maschienensprache} $B_2$ bzw. wenn ein \colorbold{Assembler} vorhanden ist, in der \colorbold{Assemblesprache} $A_2$.

  Die letzte Option wäre allerdings nur beim allerersten Compiler $C_{first}$ für eine allererste \colorbold{abstraktere Programmiersprache} $L_{first}$ mit Schleifen, Verzweigungen usw. notwendig gewesen. Ansonsten hätte man immer eine Kette, die beim allersten Compiler $C_{first}$ anfängt fortführen können, in der ein Compiler einen anderen Compiler kompiliert bzw. einen ersten minimalen Compiler kompiliert und dieser minimale Compiler dann eine umfangreichere Version von sich kompiliert usw.

  Bei einem \colorbold{Bootstrap Compiler} handelt es sich um einen Compiler in einer anderen Programiersprache $L_o$, der entweder ein \colorbold{Cross-Compiler} auf einer anderen Maschiene $M_1$ ist oder lokal auf der Maschiene $M_2$ läuft.
\end{Special_Paragraph}

\begin{Definition}{Minimaler Compiler}{minimaler_compiler}
  Compiler $C_{w\_min}$, der nur die \colorbold{notwendigsten Funktionalitäten} einer Sprache $L_w$, wie \colorbold{Schleifen},  \colorbold{Verzweigungen} kompiliert, die für die Implementierung eines \colorbold{Self-compiling Compilers} $C_{w}^{w}$ oder einer \colorbold{ersten Version} $C_{w_i}^{w_i}$ des Self-compiling Compilers $C_w^w$ für diese Sprache $L_w$ wichtig sind.\footnote{Den \colorbold{PicoC-Compiler} könnte man auch als einen \colorbold{minimalen Compiler} ansehen}
\end{Definition}{}{}

\begin{Definition}{Boostrap Compiler}{bootstrap_compiler}
  Compiler $C_o$, der es ermöglicht einen \colorbold{Self-compiling Compiler} $C_w^w$ zu \colorbold{boostrapen}, indem der Self-compiling Compiler $C_w^w$ in der Sprache $L_o$ des Bootstrap Compilers $C_o$ \colorbold{geschrieben} und mit diesem \colorbold{kompiliert} wird. Dies ermöglicht es die \colorbold{zirkulare Abhängikeit}, dass initial ein \colorbold{Self-compiling Compiler} bereits kompiliert vorliegen müsste, um sich selbst kompilieren zu können, zu brechen.

  \setcounter{defcounter}{\value{\tcbcounter}}
  \stepcounter{defcounter}
\end{Definition}

eben in einer \colorbold{Programmiersprache} $L_o$ implementiert hat, in der \colorbold{Wunschsprache} $L_w$ selbst implementieren und dann mit dem \colorbold{minamlen Compiler} für ebendiese Wunschsprache selbst kompilieren. Was man als Output bekommt ist ein \colorbold{minimmaler Compiler}, der aber auf der \colorbold{Zielmaschine} läuft und die \colorbold{Wunschsprache} in die \colorbold{Maschienensprache} der Zielmaschine kompiliert.

Aufbauend auf diesem \colorbold{minimalen Compiler}, der auf der \colorbold{Zielmaschine} läuft, kann man nun auf der Zielmaschine selbst \colorbold{iterativ} den minimalen Compiler schrittweise zu einem umfangreicheren Compiler, der mehr Funktionalitäten unterstützt weiterentwickeln und braucht die ursprüngliche Maschine, auf dem man die allererste Version des minimalen Compilers implementiert hat nicht mehr. Dieses Vorgehen wird auch als \colorbold{Bootstrapping} (Definition~\ref{def:bootstrapping}) bezeichnet.\footnote{Der Begriff hat seinen Ursprung in der englischen \colorbold{Redewendung} \glqq pulling yourself up by your own bootstraps\grqq, was im deutschen ungefähr der aus den \colorbold{Lügengeschichten des Freiherrn von Münchhausen} bekannten Redewendung \glqq sich am eigenen Schopf aus dem Sumpf ziehen\grqq entspricht.}

\begin{Definition}{Bootstrapping}{bootstrapping}
  Wenn man einen \colorbold{Self-compiling Compiler} $C_{w}^{w}$ einer Wunschsprache $L_w$ auf einer \colorbold{Zielmaschine} $M$ zum laufen bringt\footnote{Z.B. mithilfe eines \colorbold{Bootstrap Compilers}.}\footnote{Hat man einmal einen solchen \colorbold{Self-compiling Compiler} $C_{w}^{w}$ auf der Maschiene $M$ zum laufen gebracht, so kann man den Compiler auf der Maschiene $M$ weiterentwicklern, ohne von externen Entitäten, wie einer bestimmten Sprache $L_o$, in der der Compiler oder eine frühere Version des Compilers ursprünglich geschrieben war abhängig zu sein.}\footnote{Einen Compiler in der Sprache zu schreiben, die er selbst kompiliert und diesen Compiler dann sich selbst kompilieren zu lassen kann eine gute \colorbold{Probe aufs Exempel} darstellen, dass der Compiler auch wirklich funktioniert.}. Dabei ist die Art von \colorbold{Bootstrapping} in \nameref{par:bootstrapping} nochmal gesondert hervorzuheben:

  % https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
  \titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0mm}{}[:]

  % https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
  \paragraph{\thedefcounter{.1}}\label{par:bootstrapping}\hspace{-0.25cm}
  Wenn man die \colorbold{aktuelle Version} eines \colorbold{Self-compiling Compilers} $C_{w_i}^{w_i}$ der Wunschsprache $L_{w_i}$ mithilfe von \colorbold{früheren Versionen} seiner selbst kompiliert. Man schreibt also z.B. die aktuelle Version des Self-compiling Compilers in der Sprache $L_{w_{i-1}}$, welche von der früheren Version des Compilers, dem Self-compiling Compioer $C_{w_{i-1}}^{w_{i-1}}$ kompiliert wird und schafft es so \colorbold{iterativ} immer umfangreichere Compiler zu bauen.\footnote{Compiler}\footnote{Es ist hierbei nicht notwendig die aktuelle Version eines \colorbold{Self-compiling Compiler} asd}\footnote{Der Begriff ist sinnverwandt mit dem \colorbold{Booten} eines Computers, wo die wichtigste Software, der \colorbold{Kernel} zuerst in den Speicher geladen wird und darauf aufbauend von diesem dann das Betriebssysteme, welches bei Bedarf dann \colorbold{Systemsoftware}, Software, die das Ausführen von Anwendungssoftware ermöglicht oder unterstützt, wie z.B. Treiber. und \colorbold{Anwendungssoftware}, Software, deren Anwendung darin besteht, dass sie dem Benutzer unmittelbar eine Dienstleistung zur Verfügung stellt, lädt.}\footcite{earley_formalism_1970}
\end{Definition}
