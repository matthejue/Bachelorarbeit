%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1.tex
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Pointern}
\subsubsection{Referenzierung}
Die \colorbold{Referenzierung} (z.B. \verb|&var|) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_pointer_referenzierung} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={3}}]{./code_examples/example_pntr_ref.picoc}
  \caption{PicoC-Code für Pointer Referenzierung}
  \label{code:picoc_code_für_pointer_referenzierung}
\end{code}

Der Knoten \smalltt{Ref(Name('var')))} repräsentiert im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_pointer_referenzierung} eine \colorbold{Referenzierung} \verb|&var| und der Knoten \smalltt{PntrDecl(Num('1'), IntType('int'))} repräsentiert einen Pointer \smalltt{*pntr}.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10}}]{./code_examples/example_pntr_ref.ast}
  \caption{Abstract Syntax Tree für Pointer Referenzierung}
  \label{code:abstract_syntax_tree_für_pointer_referenzierung}
\end{code}

Bevor man einem \colorbold{Pointer} eine eine \colorbold{Adresse} (z.B. \smalltt{\&var}) zuweisen kann, muss dieser erstmal \colorbold{definiert} sein. Dafür braucht es einen Eintrag in der \colorbold{Symboltabelle} in Code~\ref{code:symboltabelle_für_pointer_referenzierung}.

\begin{Special_Paragraph}
Die \colorbold{Größe} eines Pointers (z.B. eines Pointers auf ein Array von \smalltt{int}: \smalltt{pntr = int *pntr[3]}), die ihm \smalltt{size}-Feld der \colorbold{Symboltabelle} eingetragen ist, ist dabei immer: $\mathtt{size(pntr) = 1}$.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={23-28}}]{./code_examples/example_pntr_ref.st}
  \caption{Symboltabelle für Pointer Referenzierung}
  \label{code:symboltabelle_für_pointer_referenzierung}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_für_pointer_referenzierung} wird der Knoten \smalltt{Ref(Name('var')))} durch die Knoten \smalltt{Ref(GlobalRead(Num('0')))} und \smalltt{Assign(GlobalWrite(Num('1')), Tmp(Num('1')))} ersetzt. Im Fall, dass in \smalltt{Ref(exp))} das \smalltt{exp} vielleicht nicht direkt ein \smalltt{Name('var')} enthält und \smalltt{exp} z.B. ein \smalltt{Subscr(Attr(Name('var')))} ist, sind noch weitere Anweisungen zwischen den Zeilen \smalltt{11} und  \smalltt{12} nötig, die sich in diesem Beispiel um das Übersetzen von \smalltt{Subscr(exp)} und \smalltt{Attr(exp)} nach dem Schema in Subkapitel~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} kümmern.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-12}}]{./code_examples/example_pntr_ref.picoc_mon}
  \caption{PicoC-Mon Pass für Pointer Referenzierung}
  \label{code:picoc_mon_für_pointer_referenzierung}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_für_pointer_referenzierung} werden die \colorbold{PicoC-Knoten} \smalltt{ Ref(Global(Num('0')))} und \smalltt{Assign(Global(Num('1')), Stack(Num('1')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={18-21,23-25}}]{./code_examples/example_pntr_ref.reti_blocks}
  \caption{RETI-Blocks Pass für Pointer Referenzierung}
  \label{code:reti_blocks_für_pointer_referenzierung}
\end{code}
% Initialisierung eines Pointers
\subsubsection{Dereferenzierung durch Zugriff auf Arrayindex ersetzen}
Die \colorbold{Dereferenzierung} (z.B. \smalltt{*var}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_pointer_dereferenzierung} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={4}}]{./code_examples/example_pntr_deref.picoc}
  \caption{PicoC-Code für Pointer Dereferenzierung}
  \label{code:picoc_code_für_pointer_dereferenzierung}
\end{code}

Der Knoten \smalltt{Deref(Name('var')))} repräsentiert im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_pointer_dereferenzierung} eine \colorbold{Dereferenzierung} \smalltt{*var}.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11}}]{./code_examples/example_pntr_deref.ast}
  \caption{Abstract Syntax Tree für Pointer Dereferenzierung}
  \label{code:abstract_syntax_tree_für_pointer_dereferenzierung}
\end{code}

Im \colorbold{PicoC-Shrink Pass} in Code~\ref{code:picoc_shrink_für_pointer_dereferenzierung} wird ein Trick angewandet, bei dem jeder Knoten \smalltt{Deref(Name('pntr'), Num('0'))} einfach durch den Knoten \smalltt{Subscr(Name('pntr'), Num('0'))} ersetzt wird. Der Trick besteht darin, dass der \colorbold{Dereferenzoperator} (z.B. \smalltt{*(var + 1)}) sich identisch zum \colorbold{Operator für den Zugriff auf einen Arrayindex} (z.B. \smalltt{var[1]}) verhält\footnote{In der Sprache $L_{C}$ gibt es einen Unterschied bei der Initialisierung bei z.B. \smalltt{int *var = \dq string\dq} und z.B. \smalltt{int var[1] = \dq string\dq}, der allerdings nichts mit den beiden Operatoren zu tuen hat, sondern mit der \colorbold{Initialisierung}, bei der die Sprache $L_{C}$ verwirrenderweise die eckigen Klammern \smalltt{[]} genauso, wie beim \colorbold{Operator für den Zugriff auf einen Arrayindex}, vor den Bezeichner schreibt (z.B. \smalltt{var[1]}), obwohl es ein \colorbold{Derived Datatype} ist.}. Damit sparrt man sich viele vermeidbare \colorbold{Fallunterscheidungen} und \colorbold{doppelten Code} und kann die \colorbold{Derefenzierung} (z.B. \smalltt{*(var + 1)}) einfach von den Routinen für einen \colorbold{Zugriff auf einen Arrayindex} (z.B. \smalltt{var[1]}) übernehmen lassen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11}}]{./code_examples/example_pntr_deref.picoc_shrink}
  \caption{PicoC-Shrink Pass für Pointer Dereferenzierung}
  \label{code:picoc_shrink_für_pointer_dereferenzierung}
\end{code}

\subsection{Umsetzung von Arrays}
\subsubsection{Initialisierung von Arrays}
\label{sec:initialisierung_von_arrays}

Die \colorbold{Initialisierung} eines \colorbold{Arrays} (z.B. \smalltt{int ar[2][1] = \{\{3+1\}, \{4\}\}}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_array_initialisierung} erklärt.

% Stack und Globale Statische Daten
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={2, 6}}]{./code_examples/example_array_init.picoc}
  \caption{PicoC-Code für Array Initialisierung}
  \label{code:picoc_code_für_array_initialisierung}
\end{code}

Die \colorbold{Initialisierung} eines \colorbold{Arrays} \smalltt{int ar[2][1] = \{\{3+1\}, \{4\}\}} wird im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_array_initialisierung} mithilfe der Komposition \smalltt{Assign(Alloc(Writeable(), ArrayDecl([Num('2'), Num('1')], IntType('int')), Name('ar')), Array([Array([BinOp(Num('3'), Add('+'), Num('1'))]), Array([Num('4')])]))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={9, 16}}]{./code_examples/example_array_init.ast}
  \caption{Abstract Syntax Tree für Array Initialisierung}
  \label{code:abstract_syntax_tree_für_array_initialisierung}
\end{code}

Bei der \colorbold{Initialisierung} eines \colorbold{Arrays} wird zuerst \smalltt{Alloc(Writeable(), ArrayDecl([Num('2'), Num('1')], IntType('int')))} ausgewertet, da eine Variable zuerst definiert sein muss, bevor man sie verwenden kann\footnote{Das Widerspricht der üblichen Auswertungsreihenfolge beim \colorbold{Zuweisungsoperator} \smalltt{=}, der \colorbold{rechtsassoziativ} ist. Der \colorbold{Zuweisungsoperator} \smalltt{=} tritt allerdings erst später in Aktion.}. Das \colorbold{Definieren} der Variable \smalltt{ar} erfolgt mittels der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_array_initialisierung} dargestellt ist.

Bei Variablen auf dem \colorbold{Stackframe} wird ein Array \colorbold{rückwärts} auf das Stackframe geschrieben und auch die \colorbold{Adresse des ersten Elements} als Adresse des Arrays genommen. Dies macht den \colorbold{Zugriff auf einen Arrayindex} in Subkapitel~\ref{sec:zugriff_auf_ein_arrayelement} deutlich unkomplizierter, da man so nicht mehr zwischen \colorbold{Stackframe} und \colorbold{Globalen Statischen Daten} beim \colorbold{Zugriff auf einen Arrayindex} unterscheiden muss, da es Probleme macht, dass ein \colorbold{Stackframe} in die entgegengesetzte Richtung wächst, verglichen mit den \colorbold{Globalen Statischen Daten}\footnote{Wenn man beim \colorbold{GCC}~\cite{noauthor_gcc_nodate} einen Stackframe mittels des \colorbold{GDB}~\cite{noauthor_gcc_nodate} beobachtet, sieht man, dass dieser es genauso macht.}.

\begin{Special_Paragraph}
  Das \colorbold{Größe} des Arrays $\mathtt{datatype \enspace ar[dim_1]\ldots[dim_k]}$, die ihm \smalltt{size}-Feld des \colorbold{Symboltabelleneintrags} eingetragen ist, berechnet sich dabei aus der \colorbold{Mächtigkeit} der einzelnen \colorbold{Dimensionen} des Arrays multipliziert mit der \colorbold{Größe} des \colorbold{grundlegenden Datentyps} der einzelnen \colorbold{Arrayelemente}: $\mathtt{size(datatype(ar)) = \left(\prod^n_{j=1} dim_j\right)\cdot size(datatype)}$\footnote{Die \colorbold{Funktion}  \smalltt{type} ordnet einer  \colorbold{Variable} ihren \colorbold{Datentyp} zu. Das ist notwendig, weil die \colorbold{Funktion} \smalltt{size} nur bei einem \colorbold{Datentyp} als \colorbold{Funktionsargument} die \colorbold{Größe dieses Datentyps} als \colorbold{Zielwert} liefert}.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={14-19,32-37}}]{./code_examples/example_array_init.st}
  \caption{Symboltabelle für Array Initialisierung}
  \label{code:symboltabelle_für_array_initialisierung}
\end{code}

Im \colorbold{PiocC-Mon Pass} in Code~\ref{code:picoc_mon_für_array_initialisierung} werden zuerst die \colorbold{Logischen Ausdrücke} in den Blättern des vom \colorbold{Array-Initializers} \colorbold{Container-Knoten} ausgehenden Baumes \smalltt{Array([Array([BinOp(Num('3'), Add('+'), Num('1'))]), Array([Num('4')])])} nach dem \colorbold{Depth-First-Search} Schema, von \colorbold{links-nach-rechts} ausgewertet und auf den \colorbold{Stack} geschrieben\footnote{Da der \colorbold{Zuweisungsoperator} \smalltt{=} \colorbold{rechtsassoziativ} ist und auch rein \colorbold{logisch}, weil man nichts zuweisen kann, was man noch nicht berechnet hat.}.

Im finalen Schritt muss zwischen \colorbold{Globalen Statischen Daten} bei der \smalltt{main}-Funktion und \colorbold{Stackframe} bei der Funktion \smalltt{fun} unterschieden werden. Die auf den Stack ausgewerteten Expressions werden mittels der Komposition \smalltt{Assign(Global(Num('0')), Stack(Num('2')))} bzw. \smalltt{Assign(Stackframe(Num('3')), Stack(Num('4')))}, die in Tabelle~\ref{tab:kompositionen_von_picoc_knoten_und_reti_knoten_mit_besonderer_bedeutung} genauer beschrieben ist, versetzt in der selben Reihenfolge zu den \colorbold{Globalen Statischen Daten} bzw. auf den \colorbold{Stackframe} geschrieben.

Der \colorbold{Trick} ist hier, dass egal wieviele Dimensionen und was für einen Datentyp das \colorbold{Array} hat, man letztendlich immer das gesamte Array erwischt, wenn man einfach die \colorbold{Größe des Arrays} viele \colorbold{Speicherzellen} mit z.B. der \colorbold{Komposition} \smalltt{Assign(Global(Num('0')), Stack(Num('2')))} verschiebt.

In die Knoten \smalltt{Global('0')} und  \smalltt{Stackframe('3')} wurde hierbei die \colorbold{Startadresse} des jeweiligen Arrays geschrieben, sodass man nach dem \colorbold{PicoC-Mon Pass} nie mehr Variablen in der  \colorbold{Symboltabelle} nachsehen muss und gleich weiß, ob sie in Bezug zu den \colorbold{Globalen Statischen Daten} oder dem \colorbold{Stackframe} stehen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={8-12,19-23}}]{./code_examples/example_array_init.picoc_mon}
  \caption{PicoC-Mon Pass für Array Initialisierung}
  \label{code:picoc_mon_für_array_initialisierung}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_für_array_initialisierung} werden die \colorbold{Kompositionen} \smalltt{Exp(exp)} und \smalltt{Assign(Global(Num('0')), Stack(Num('2')))} bzw. \smalltt{Assign(Stackframe(Num('3')), Stack(Num('4')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={9-11,13-15,17-21,23-25,27-31,40-42,44-46,48-50,52-54,56-64}}]{./code_examples/example_array_init.reti_blocks}
  \caption{RETI-Blocks Pass für Array Initialisierung}
  \label{code:reti_blocks_für_array_initialisierung}
\end{code}


% kleines Extra
\subsubsection{Zugriff auf einen Arrayindex}
\label{sec:zugriff_auf_ein_arrayelement}

Der \colorbold{Zugriff auf einen Arrayindex} (z.B. \smalltt{ar[0]}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_zugriff_auf_arrayindex} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={3,8}}]{./code_examples/example_array_access.picoc}
  \caption{PicoC-Code für Zugriff auf einen Arrayindex}
  \label{code:picoc_code_für_zugriff_auf_arrayindex}
\end{code}

Der \colorbold{Zugriff auf einen Arrayindex} \smalltt{ar[0]} wird im  \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_zugriff_auf_arrayindex} mithilfe des \colorbold{Container-Knotens} \smalltt{Subscr(Name('ar'), Num('0'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10,18}}]{./code_examples/example_array_access.ast}
  \caption{Abstract Syntax Tree für Zugriff auf einen Arrayindex}
  \label{code:abstract_syntax_tree_für_zugriff_auf_arrayindex}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_für_zugriff_auf_arrayindex} wird vom \colorbold{Container-Knoten} \smalltt{Subscr(Name('ar'), Num('0'))} zuerst im \colorbold{Anfangsteil}~\ref{sec:einleitungsteil_für_globale_statische_daten_und_stackframe} die \colorbold{Adresse} der Variable \smalltt{Name('ar')} auf den \colorbold{Stack} geschrieben. Bei den \colorbold{Globalen Statischen Daten} der \smalltt{main}-Funktion wird das durch die Komposition \smalltt{Ref(Global(Num('0')))} dargestellt und beim \colorbold{Stackframe} der Funktionm \smalltt{fun} wird das durch die Komposition \smalltt{Ref(Stackframe(Num('2')))} dargestellt.

In nächsten Schritt, dem \colorbold{Mittelteil}~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} wird die Adresse des \colorbold{Index}, des Arrays auf das Zugegriffen werden soll berechnet. Da der \colorbold{Index} auf den Zugegriffen werden soll auch durch das Ergebnis eines \colorbold{komplexeren Ausdrucks}, z.B. \smalltt{ar[1 + var]} bestimmt sein kann, indem auch \colorbold{Variablen} vorkommen können, kann dieser nicht während des \colorbold{Kompilierens} berechnet werden, sondern muss zur \colorbold{Laufzeit} berechnet werden.

Daher muss zuerst der Wert des \colorbold{Index}, dessen Adresse berechnet werden soll bestimmt werden, z.B. im einfachen Fall durch \smalltt{Exp(Num('0'))} und dann muss die \colorbold{Adresse des Index} berechnet werden, was durch die Komposition \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} dargestellt wird. Die Bedeutung der Komposition \smalltt{\smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))}} ist in Tabelle~\ref{tab:kompositionen_von_picoc_knoten_und_reti_knoten_mit_besonderer_bedeutung} dokumentiert.

Je nachdem, ob mehrere \smalltt{Subscr(exp, exp)} eine Komposition bilden (z.B. \smalltt{Subscr(Subscr(Name('var'), Num('1')), Num('1'))}) ist es notwendig mehrere \colorbold{Adressberechnungsschritte für den Index} \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} einzuleiten und es muss auch möglich sein, z.B. einen \colorbold{Attributzugriff} \smalltt{var.attr} und eine \colorbold{Zugriff auf einen Arryindex} \smalltt{var[1]} miteinander zu kombinieren, was in Subkapitel~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} allgemein erklärt ist.

Im letzten Schritt, dem \colorbold{Schlussteil}~\ref{sec:schlussteil_für_die_verschiedenen_derived_datatypes} wird der \colorbold{Inhalt} des \colorbold{Index}, dessen \colorbold{Adresse} in den vorherigen Schritten berechnet wurde, nun auf den \colorbold{Stack} geschrieben, wobei dieser die \colorbold{Adresse} auf dem Stack ersetzt, die es zum Finden des \colorbold{Index} brauchte. Dies wird durch den Knoten \smalltt{Exp(Stack(Num('1')))} dargestellt. Je nachdem, welchen \colorbold{Datentyp} die Variable \smalltt{ar} hat und auf welchen \colorbold{Subdatentyp}, welcher ein \textcolor{gray!90!black}{verstecktes Attribut} des \smalltt{Exp(Stack(Num('1')))} Knoten ist folglich im \colorbold{Kontext} zuletzt zugegriffen wird, abhängig davon wird der \colorbold{Schlussteil} \smalltt{Exp(Stack(Num('1')))} auf eine andere Weise verarbeitet (siehe Subkapitel~\ref{sec:schlussteil_für_die_verschiedenen_derived_datatypes}).

Der einzige \colorbold{Unterschied}, je nachdem, ob der \colorbold{Zugriff auf einen Arrayindex} (z.B. \smalltt{ar[1]}) in der  \smalltt{main}-Funktion oder der Funktion \smalltt{fun} erfolgt, ist eigentlich nur beim \colorbold{Anfangsteil}, beim Schreiben der \colorbold{Adresse} der Variable \smalltt{ar} auf den \colorbold{Stack} zu finden, bei dem unterschiedliche \colorbold{RETI-Instructions} für eine Variable, die in den \colorbold{Globalen Statischen Daten} liegt und eine Variable, die auf dem \colorbold{Stackframe} liegt erzeugt werden müssen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-14,26}}]{./code_examples/example_array_access.picoc_mon}
  \caption{PicoC-Mon Pass für Zugriff auf einen Arrayindex}
  \label{code:picoc_mon_für_zugriff_auf_arrayindex}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_für_zugriff_auf_arrayindex} werden die \colorbold{Kompositionen} \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Subscr(Stack(Num('2')) und Stack(Num('1'))))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={18-21,23-25,27-32,34-36,66-69}}]{./code_examples/example_array_access.reti_blocks}
  \caption{RETI-Blocks Pass für Zugriff auf einen Arrayindex}
  \label{code:reti_blocks_für_zugriff_auf_arrayindex}
\end{code}

\subsubsection{Zuweisung an Arrayindex}
% Formel aus der Vorlesung, wo ist die hier?

Die \colorbold{Zuweisung} eines Wertes an einen \colorbold{Arrayindex} (z.B. \smalltt{ar[2] = 42;}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_array_assignment} erläutert.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={3}}]{./code_examples/example_array_assignment.picoc}
  \caption{PicoC-Code für Zuweisung an Arrayindex}
  \label{code:picoc_code_für_array_assignment}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_array_assignment} wird eine \colorbold{Zuweisung} an einen \colorbold{Arrayindex} \smalltt{ar[2] = 42;} durch die Komposition \smalltt{Assign(Subscr(Name('ar'), Num('2')), Num('42'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10}}]{./code_examples/example_array_assignment.ast}
  \caption{Abstract Syntax Tree für Zuweisung an Arrayindex}
  \label{code:abstract_syntax_tree_für_array_assignment}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_für_array_assignment} wird zuerst die \colorbold{rechte} Seite des \colorbold{rechtsassoziativen} Zuweisungsoperators \smalltt{=}, bzw. des \colorbold{Container-Knotens} der diesen darstellt ausgewertet: \smalltt{Exp(Num('42'))}.

Danach ist das Vorgehen, bzw. sind die Kompostionen, die dieses darauffolgende Vorgehen darstellen: \smalltt{Ref(Global(Num('0')))}, \smalltt{Exp(Num('2'))} und \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} identisch zum \colorbold{Anfangsteil} und \colorbold{Mittelteil} aus dem vorherigen Subkapitel~\ref{sec:zugriff_auf_ein_arrayelement}. Es wird die \colorbold{Adresse} des \colorbold{Index}, dem das Ergebnis der Ausdrucks auf der rechten Seite des \colorbold{Zuweisungsoperators} \smalltt{=} zugewiesen wird berechet, wie in Subkapitel~\ref{sec:zugriff_auf_ein_arrayelement}.

Zum Schluss stellt die \colorbold{Komposition} \smalltt{Assign(Stack(Num('1')), Stack(Num('2')))}\footnote{Ist in Tabelle~\ref{tab:kompositionen_von_picoc_knoten_und_reti_knoten_mit_besonderer_bedeutung} genauer beschrieben ist} die Zuweisung \smalltt{=} des Ergebnisses des Ausdrucks auf der \colorbold{rechten} Seite der Zuweisung zum \colorbold{Arrayindex}, dessen \colorbold{Adresse} im Schritt danach berechnet wurde dar.

\begin{Special_Paragraph}
  Die Berechnung der \colorbold{Adresse}, ab der ein \colorbold{Arrayelement} eines Arrays $\mathtt{datatype\enspace ar[dim_1]\ldots[dim_n]}$ abgespeichert ist, kann mittels der Formel~\ref{eq:adresse_von_arrayelement}:

  \numberwithin{equation}{section}

  \begin{equation}
  \mathtt{ref(ar[idx_1]\ldots[idx_n]) = ref(ar) + \left(\sum_{i=1}^{n}\left(\prod_{j=i+1}^{n} dim_{j}\right) \cdot idx_{i}\right) \cdot \operatorname{size}(datatype)} \\
    \label{eq:adresse_von_arrayelement}
  \end{equation}
  aus der Betriebssysteme Vorlesung\footcite{scholl_betriebssysteme_2020} berechnet werden\footnote{\smalltt{ref(exp)} steht dabei für die Berechnung der \colorbold{Adresse} von \smalltt{exp}, wobei \smalltt{exp} z.B. \smalltt{ar[3][2]} sein könnte}.

  Die Kompositionen \smalltt{Ref(Global(Num('0')))} und \smalltt{Ref(Stackframe(Num('2')))} repräsentiert dabei den Summanden $\smalltt{ref(ar)}$ in der Formel.

  Die Komposition \smalltt{Exp(Num('2'))} repräsentiert dabei einen \colorbold{Subindex} (z.B. \smalltt{i} in \smalltt{a[i][j][k]}) beim \colorbold{Zugriff auf ein Arrayelement}, der als Faktor $\mathtt{idx_i}$ in der Formel auftaucht.

  Der Komposition \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} repräsentiert dabei einen ausmultiplizierten Summanden $\mathtt{\left(\prod_{j=i+1}^{n} dim_{j}\right) \cdot idx_{i} \cdot size(datatpye)}$ in der Formel.

Die Komposition \smalltt{Exp(Stack(Num('1')))} repräsentiert dabei das Lesen des \colorbold{Inhalts} $\mathtt{M\left[ref(ar[idx_1]\ldots[idx_n])\right]}$ der Speicherzelle an der finalen \colorbold{Adresse}  $\mathtt{ref(ar[idx_1]\ldots[idx_n])}$.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={9-13}}]{./code_examples/example_array_assignment.picoc_mon}
  \caption{PicoC-Mon Pass für Zuweisung an Arrayindex}
  \label{code:picoc_mon_für_array_assignment}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_für_array_assignment} werden die \colorbold{Kompositionen} \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} und \smalltt{Assign(Stack(Num('1')), Stack(Num('2')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10-12,14-17,19-21,23-28,30-33}}]{./code_examples/example_array_assignment.reti_blocks}
  \caption{RETI-Blocks Pass für Zuweisung an Arrayindex}
  \label{code:reti_blocks_für_array_assignment}
\end{code}

\subsection{Umsetzung von Structs}
\subsubsection{Deklaration und Definition von Structtypen}

Die \colorbold{Deklaration} eines neuen \colorbold{Structtyps} (z.B. \smalltt{struct st \{int len; int ar[2];\};}) und die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp} (z.B. \smalltt{struct st st\_var;}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_die_deklaration_eines_structtyps} erläutert.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,4}}]{./code_examples/example_struct_decl_def.picoc}
  \caption{PicoC-Code für die Deklaration eines Structtyps}
  \label{code:picoc_code_für_die_deklaration_eines_structtyps}
\end{code}

Bevor irgendwas definiert werden kann, muss erstmal ein \colorbold{Structtyp} deklariert werden. Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} wird die \colorbold{Deklaration eines Structtyps} \smalltt{struct st \{int len; int ar[2];\};} durch die Komposition \smalltt{StructDecl(Name('st'), [Alloc(Writeable(), IntType('int'), Name('len')) Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} dargestellt.

Die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp}  \smalltt{struct st st\_var;}  wird durch die Komposition \smalltt{Alloc(Writeable(), StructSpec(Name('st')), Name('st\_var'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,15}}]{./code_examples/example_struct_decl_def.ast}
  \caption{Abstract Syntax Tree für die Deklaration eines Structtyps}
  \label{code:abstract_syntax_tree_für_die_deklaration_eines_structtyps}
\end{code}

Für den \colorbold{Structtyp} selbst wird in der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} dargestellt ist ein Eintrag mit dem \colorbold{Schlüssel} \smalltt{st} erstellt. Die Felder dieses Eintrags \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{position} und \smalltt{size} sind wie üblich belegt, allerdings sind in dem \smalltt{value\_address}-Feld die Attribute des \colorbold{Structtyps} \smalltt{[Name('len@st'), Name('ar@st')]} aufgelistet, sodass man über den \colorbold{Structtyp} \smalltt{st} die  \colorbold{Attribute} des Structtyps in der  \colorbold{Symboltabelle} nachschlagen kann. Die Schlüssel der \colorbold{Attribute} haben einen \colorbold{Suffix} \smalltt{@st} angehängt, der eine Art \colorbold{Scope} innerhalb des \colorbold{Structtyps} für seine Attribut darstellt. Es gilt foglich, dass \colorbold{innerhalb} eines \colorbold{Structtyps} zwei Attribute nicht gleich benannt werden können, aber dafür zwei \colorbold{unterschiedliche} \colorbold{Structtypen} ihre Attribute gleich benennen können.

Jedes der \colorbold{Attribute} \smalltt{[Name('len@st'), Name('ar@st')]} erhält auch einen eigenen Eintrag in der \colorbold{Symboltabelle}, wobei die Felder \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{value\_address}, \smalltt{position} und \smalltt{size} wie üblich belegt werden. Die Felder \smalltt{type\_qualifier}, \smalltt{datatype} und \smalltt{name} werden z.B. bei \smalltt{Name('ar@st')} mithilfe der Attribute von \smalltt{Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} belegt.

Für die \colorbold{Definition} einer Variable \smalltt{st\_var@main} mit diesem \colorbold{Structtyp} \smalltt{st} wird ein Eintrag in der \colorbold{Symboltabelle} angelegt. Das \smalltt{datatyp}-Feld enhält dabei den Namen des \colorbold{Structtyps} als Komposition \smalltt{StructSpec(Name('st'))}, wodurch jederzeit alle wichtigen Informationen zu diesem \colorbold{Structyp} und seinen \colorbold{Attributen} in der  \colorbold{Symboltabelle} nachgeschlagen werden können.

% https://tex.stackexchange.com/questions/1959/allowing-line-break-at-in-inline-math-mode
\begin{Special_Paragraph}
  Die \colorbold{Größe} einer Variable \smalltt{st\_var}, die ihm \smalltt{size}-Feld des \colorbold{Symboltabelleneintrags} eingetragen ist und mit dem \colorbold{Structtyp} $\mathtt{struct\enspace st\enspace \{datatype_1\enspace attr_1;\enspace\ldots\enspace datatype_n\enspace attr_n;\};}$\footnote{Hier wird es der Einfachheit halber so dargestellt, als hätte die Programmiersprache $L_{PicoC}$ nicht die Fragwürdige Designentscheidung, auch die eckigen Klammern \smalltt{[]} für die Definition eines Arrays \colorbold{vor} die Variable zu schreiben von $\mathtt{L_C}$ übernommen. Es wird so getann, als würde der komplette \colorbold{Datentyp} immer \colorbold{hinter} der Variable stehen: \smalltt{datatype var}.} definiert ist ($\mathtt{struct\enspace st\enspace st\_var;}$), berechnet sich dabei aus der Summe der \colorbold{Größen} der einzelnen \colorbold{Datentypen} $\mathtt{datatype_1\enspace \ldots\enspace datatpye_n}$ der \colorbold{Attribute} $\mathtt{attr_1,\enspace \ldots\enspace attr_n}$ des  \colorbold{Structtyps}: $\mathtt{size(st) = \sum^n_{i=1} size(datatype_i)}$.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={5-10,14-19,23-28,41-46}}]{./code_examples/example_struct_decl_def.st}
  \caption{Symboltabelle für die Deklaration eines Structtyps}
  \label{code:symboltabelle_für_die_deklaration_eines_structtyps}
\end{code}

\subsubsection{Initialisierung von Structs}

Die \colorbold{Initialisierung eines Structs} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_initialisierung_von_structs} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={7}}]{./code_examples/example_struct_init.picoc}
  \caption{PicoC-Code für Initialisierung von Structs}
  \label{code:picoc_code_für_initialisierung_von_structs}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_initialisierung_von_structs} wird die \colorbold{Initialisierung eines Structs} \smalltt{struct st1 st = \{.attr1=var, .attr2=\{.attr=\{\{\&var, \&var\}\}\}\};} mithilfe der \colorbold{Komposition} \smalltt{Assign(Alloc(Writeable(), StructSpec(Name('st1')), Name('st')), Struct(\ldots))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={21}}]{./code_examples/example_struct_init.ast}
  \caption{Abstract Syntax Tree für Initialisierung von Structs}
  \label{code:abstract_syntax_tree_für_initialisierung_von_structs}
\end{code}

Im Folgenden ist der Ablauf fast identisch zur \colorbold{Initialisierung eines Arrays} in Subkapitel~\ref{sec:initialisierung_von_arrays}, daher wird um keine Wiederholung zu betreiben auf Subkapitel~\ref{sec:initialisierung_von_arrays} verwiesen. Um das ganze interressanter zu gestalten wird in das Beispiel in Code~\ref{code:picoc_code_für_initialisierung_von_structs} so gewählt, dass es eine komplexere, mehrstufige Initialisierung mit \colorbold{verschiedenen} Datentypen erklärt.

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_initialisierung_von_structs} wird der \colorbold{Struct-Initializer} fast genauso ausgewertet, wie der \colorbold{Array-Initializer} in Subkapitel~\ref{sec:initialisierung_von_arrays}. Beim \colorbold{Struct-Initializer} (z.B. \smalltt{Struct([Assign(Name('attr1'), Name('var')), Assign(Name('attr2'), Struct([Assign(Name('attr'), Array([Array([Ref(Name('var')), Ref(Name('var'))])]))]))])}) muss allerdings beachtet werden, dass weitere \colorbold{Struct- oder Array-Initializer} und \colorbold{Logische Ausdrücke} immer im rechten \smalltt{exp} Knoten des \smalltt{Assign(lhs, exp)}-Knoten (z.B. \smalltt{Assign(Name('attr1'), Name('var'))}) zu finden sind.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-14}}]{./code_examples/example_struct_init.picoc_mon}
  \caption{PicoC-Mon Pass für Initialisierung von Structs}
  \label{code:picoc_mon_pass_für_initialisierung_von_structs}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_initialisierung_von_structs} werden die \colorbold{Kompositionen} \smalltt{Exp(exp)}, \smalltt{Ref(exp)} und \smalltt{Assign(Global(Num('1')), Stack(Num('3')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={18-20,22-25,27-30,32-38}}]{./code_examples/example_struct_init.reti_blocks}
  \caption{RETI-Blocks Pass für Initialisierung von Structs}
  \label{code:reti_blocks_pass_für_initialisierung_von_structs}
\end{code}

% Stack und Globale Statische Daten
\subsubsection{Zugriff auf Structattribut}
% Formel aus der Vorlesung, wo ist die hier?

Der \colorbold{Zugriff auf ein Structattribut} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_initialisierung_von_structs} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_access.picoc}
  \caption{PicoC-Code für Zugriff auf Structattribut}
  \label{code:picoc_code_für_zugriff_auf_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_access.ast}
  \caption{Abstract Syntax Tree für Zugriff auf Structattribut}
  \label{code:abstract_syntax_tree_für_zugriff_auf_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-14}}]{./code_examples/example_struct_attr_access.picoc_mon}
  \caption{PicoC-Mon Pass für Zugriff auf Structattribut}
  \label{code:picoc_mon_pass_für_zugriff_auf_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-27,29-31,33-35}}]{./code_examples/example_struct_attr_access.reti_blocks}
  \caption{RETI-Blocks Pass für Zugriff auf Structattribut}
  \label{code:reti_blocks_pass_für_zugriff_auf_structattribut}
\end{code}

\subsubsection{Zuweisung an Structattribut}
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_assignment.picoc}
  \caption{PicoC-Code für Zuweisung an Structattribut}
  \label{code:picoc_code_für_zuweisung_an_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_assignment.ast}
  \caption{Abstract Syntax Tree für Zuweisung an Structattribut}
  \label{code:abstract_syntax_tree_für_zuweisung_an_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-15}}]{./code_examples/example_struct_attr_assignment.picoc_mon}
  \caption{PicoC-Mon Pass für Zuweisung an Structattribut}
  \label{code:picoc_mon_pass_für_zuweisung_an_structattribut}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-26,28-31,33-35,37-40}}]{./code_examples/example_struct_attr_assignment.reti_blocks}
  \caption{RETI-Blocks Pass für Zuweisung an Structattribut}
  \label{code:reti_blocks_pass_für_zuweisung_an_structattribut}
\end{code}

\subsection{Umsetzung der Derived Datatypes im Zusammenspiel}
\subsubsection{Anfangsteil für Globale Statische Daten und Stackframe}
\label{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}
% Stack und Globale Statische Daten, unterschieldihe Berechnung der Adressen
% unterschiedliche Adressberechnung
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_derived_dts_introduction_part.picoc}
  \caption{PicoC-Code für den Anfangsteil}
  \label{code:picoc_code_einleitungsteil}
\end{code}

% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_introduction_part.ast}
  \caption{Abstract Syntax Tree für den Anfangsteil}
  \label{code:abstract_syntax_tree_einleitungsteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_introduction_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Anfangsteil}
  \label{code:picoc_mon_pass_einleitungsteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_introduction_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Anfangsteil}
  \label{code:reti_blocks_pass_einleitungsteil}
\end{code}

\subsubsection{Mittelteil für die verschiedenen Derived Datatypes}
\label{sec:mittelteil_für_die_verschiedenen_derived_datatypes}

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_derived_dts_main_part.picoc}
  \caption{PicoC-Code für den Mittelteil}
  \label{code:picoc_code_mittelteil}
\end{code}

% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_main_part.ast}
  \caption{Abstract Syntax Tree für den Mittelteil}
  \label{code:abstract_syntax_tree_mittelteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_main_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Mittelteil}
  \label{code:picoc_mon_pass_mittelteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_main_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Mittelteil}
  \label{code:reti_blocks_pass_mittelteil}
\end{code}
% spezielles Vorgehen bei PntrDecl

\subsubsection{Schlussteil für die verschiedenen Derived Datatypes}
\label{sec:schlussteil_für_die_verschiedenen_derived_datatypes}
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_derived_dts_final_part.picoc}
  \caption{PicoC-Code für den Schlussteil}
  \label{code:picoc_code_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_final_part.ast}
  \caption{Abstract Syntax Tree für den Schlussteil}
  \label{code:abstract_syntax_tree_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_final_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Schlussteil}
  \label{code:picoc_mon_pass_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_derived_dts_final_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Schlussteil}
  \label{code:reti_blocks_pass_schlussteil}
\end{code}

% Umgang, wenn Datentyp abrubt aufhört am Ende

\subsection{Umsetzung von Funktionen}
\subsubsection{Funktionen auflösen zu RETI Code}
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_3_funs.picoc}
  \caption{PicoC-Code für 3 Funktionen}
  \label{code:picoc_code_für_3_Funktionen}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs.ast}
  \caption{Abstract Syntax Tree für 3 Funktionen}
  \label{code:abstract_syntax_tree_für_3_Funktionen}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs.picoc_blocks}
  \caption{RETI-Blocks Pass für 3 Funktionen}
  \label{code:picoc_blocks_pass_für_3_Funktionen}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs.picoc_mon}
  \caption{PicoC-Mon Pass für 3 Funktionen}
  \label{code:picoc_mon_pass_für_3_Funktionen}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs.reti_blocks}
  \caption{RETI-Blocks Pass für 3 Funktionen}
  \label{code:reti_blocks_pass_für_3_Funktionen}
\end{code}

% einfügen unsichtbarer Returns bei void
\newlineparagraph{Sprung zur Main Funktion}

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_3_funs_main.picoc}
  \caption{PicoC-Code für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs_main.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_mon_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs_main.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs_main.reti_patch}
  \caption{PicoC-Patch Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\subsubsection{Funktionsdeklaration und -definition und Umsetzung von Scopes}
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_3_funs_fun_decl.picoc}
  \caption{PicoC-Code für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

Bei mehreren Funktionen werden die \colorbold{Scopes} der unterschiedlichen \colorbold{Funktionen} mittels eines \colorbold{Suffix} \smalltt{\dq <fun\_name>@\dq} umgesetzt, der an den \colorbold{Variablennamen} \smalltt{<var>} drangehängt wird: \smalltt{<var>@<fun\_name>}. Dieser \colorbold{Suffix} wird geändert sobald beim \colorbold{Top-Down}\footnote{D.h. von der Wurzel zu den Blättern eines Baumes} Durchiterieren über den \colorbold{Abstract Syntax Tree} des aktuellen \colorbold{Passes} nach dem \colorbold{Depth-First-Search} Schema über den

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_3_funs_fun_decl.st}
  \caption{Symboltabelle für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

% Allocation von Variablen
% Stack und Globale Statische Daten
% die Sache mit Assign(Tmp, Global) und Assign(Global, Tmp)
% erwähnen, das Main Funktion keinen Stackframe hat
% zählen der Größe der lokalen Daten und Parameter
% TODO: Signatur zu Parameter umbenennen
\subsubsection{Funktionsaufruf}

\newlineparagraph{Ohne Rückgabewert}

% Unsichtbares return
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_fun_call_no_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_no_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_no_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_no_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\newlineparagraph{Mit Rückgabewert}

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/example_fun_call_with_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_with_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_with_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/example_fun_call_with_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\newlineparagraph{Umsetzung von Call by Sharing für Arrays}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,7}}]{./code_examples/example_fun_call_by_sharing_array.picoc}
  \caption{PicoC-Code für Call by Sharing für Arrays}
  \label{code:picoc_code_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-20}}]{./code_examples/example_fun_call_by_sharing_array.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Sharing für Arrays}
  \label{code:picoc_mon_pass_für_call_by_sharing_für_arrays}
\end{code}


% https://tex.stackexchange.com/questions/298383/how-to-highlight-color-draw-attention-to-a-particular-snippet-in-minted/498614#498614
\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15,24}}]{./code_examples/example_fun_call_by_sharing_array.st}
  \caption{Symboltabelle für Call by Sharing für Arrays}
  \label{code:symboltabelle_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-20}}]{./code_examples/example_fun_call_by_sharing_array.reti_blocks}
  \caption{RETI-Block Pass für Call by Sharing für Arrays}
  \label{code:reti_blocks_pass_für_call_by_sharing_für_arrays}
\end{code}

% die Sache mit dem erstetzen von ArryDecl durch PntrDecl

\newlineparagraph{Umsetzung von Call by Value für Structs}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8}}]{./code_examples/example_fun_call_by_value_struct.picoc}
  \caption{PicoC-Code für Call by Value für Structs}
  \label{code:picoc_code_für_call_by_value_für_structs}
\end{code}

% argmode für Struct Call by Value

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-19}}]{./code_examples/example_fun_call_by_value_struct.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Value für Structs}
  \label{code:picoc_mon_pass_für_call_by_value_for_structs}
\end{code}

% hier könnte man anmerken, dass die Adressen unterschiedlich berechnet werden für Stack und Globale...

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-19}}]{./code_examples/example_fun_call_by_value_struct.reti_blocks}
  \caption{RETI-Block Pass für Call by Value für Structs}
  \label{code:reti_blocks_pass_für_call_by_value_for_structs}
\end{code}

% Struct wird wirklich kopiert durch speziellen Argmode

\subsection{Umsetzung kleinerer Details}
% langen Sprüngen, großen Konstanten, Division durch 0
\section{Fehlermeldungen}
\subsection{Error Handler}
\subsection{Arten von Fehlermeldungen}
\subsubsection{Syntaxfehler}
\subsubsection{Laufzeitfehler}
% Fehlermeldung ist, wenn der Lexer (partielle Funktion) oder Parser nicht matcht
% Token und Nodes enthalten Position, im Transformer wird die Position von den Token auf die Nodes übertragen und auch die Symboltabelle speichert Position
