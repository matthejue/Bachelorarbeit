%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1_Tables_DT_AST.tex,
% ./Implementierung2_Pntr_Array.tex,
% ./Implementierung4_Fun.tex,
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Structs}
\label{sec:umsetzung_von_structs}
\subsubsection{Deklaration und Definition von Structtypen}

Die \colorbold{Deklaration} eines neuen \colorbold{Structtyps} (z.B. \smalltt{struct st \{int len; int ar[2];\};}) und die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp} (z.B. \smalltt{struct st st\_var;}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_die_deklaration_eines_structtyps} erläutert.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,4}}]{./code_examples/example_struct_decl_def.picoc}
  \caption{PicoC-Code für die Deklaration eines Structtyps}
  \label{code:picoc_code_für_die_deklaration_eines_structtyps}
\end{code}

Bevor irgendwas definiert werden kann, muss erstmal ein \colorbold{Structtyp} deklariert werden. Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} wird die \colorbold{Deklaration eines Structtyps} \smalltt{struct st \{int len; int ar[2];\};} durch die Komposition \smalltt{StructDecl(Name('st'), [Alloc(Writeable(), IntType('int'), Name('len')) Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} dargestellt.

Die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp}  \smalltt{struct st st\_var;}  wird durch die Komposition \smalltt{Alloc(Writeable(), StructSpec(Name('st')), Name('st\_var'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,15}}]{./code_examples/example_struct_decl_def.ast}
  \caption{Abstract Syntax Tree für die Deklaration eines Structtyps}
  \label{code:abstract_syntax_tree_für_die_deklaration_eines_structtyps}
\end{code}

Für den \colorbold{Structtyp} selbst wird in der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} dargestellt ist ein Eintrag mit dem \colorbold{Schlüssel} \smalltt{st} erstellt. Die Felder dieses Eintrags \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{position} und \smalltt{size} sind wie üblich belegt, allerdings sind in dem \smalltt{value\_address}-Feld die Attribute des \colorbold{Structtyps} \smalltt{[Name('len@st'), Name('ar@st')]} aufgelistet, sodass man über den \colorbold{Structtyp} \smalltt{st} die  \colorbold{Attribute} des Structtyps in der  \colorbold{Symboltabelle} nachschlagen kann. Die Schlüssel der \colorbold{Attribute} haben einen \colorbold{Suffix} \smalltt{@st} angehängt, der eine Art \colorbold{Scope} innerhalb des \colorbold{Structtyps} für seine Attribut darstellt. Es gilt foglich, dass \colorbold{innerhalb} eines \colorbold{Structtyps} zwei Attribute nicht gleich benannt werden können, aber dafür zwei \colorbold{unterschiedliche} \colorbold{Structtypen} ihre Attribute gleich benennen können.

Jedes der \colorbold{Attribute} \smalltt{[Name('len@st'), Name('ar@st')]} erhält auch einen eigenen Eintrag in der \colorbold{Symboltabelle}, wobei die Felder \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{value\_address}, \smalltt{position} und \smalltt{size} wie üblich belegt werden. Die Felder \smalltt{type\_qualifier}, \smalltt{datatype} und \smalltt{name} werden z.B. bei \smalltt{Name('ar@st')} mithilfe der Attribute von \smalltt{Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} belegt.

Für die \colorbold{Definition} einer Variable \smalltt{st\_var@main} mit diesem \colorbold{Structtyp} \smalltt{st} wird ein Eintrag in der \colorbold{Symboltabelle} angelegt. Das \smalltt{datatyp}-Feld enthält dabei den Namen des \colorbold{Structtyps} als Komposition \smalltt{StructSpec(Name('st'))}, wodurch jederzeit alle wichtigen Informationen zu diesem \colorbold{Structyp}\footnote{Wie z.B. vor allem die \colorbold{Größe} bzw. \colorbold{Anzahl an Speicherzellen}, die dieser \colorbold{Structtyp} einnimmt.} und seinen \colorbold{Attributen} in der  \colorbold{Symboltabelle} nachgeschlagen werden können.

% https://tex.stackexchange.com/questions/1959/allowing-line-break-at-in-inline-math-mode
\begin{Special_Paragraph}
  Die \colorbold{Größe} einer Variable \smalltt{st\_var}, die ihm \smalltt{size}-Feld des \colorbold{Symboltabelleneintrags} eingetragen ist und mit dem \colorbold{Structtyp} $\mathtt{struct\enspace st\enspace \{datatype_1\enspace attr_1;\enspace\ldots\enspace datatype_n\enspace attr_n;\};}$\footnote{Hier wird es der Einfachheit halber so dargestellt, als hätte die Programmiersprache $L_{PicoC}$ nicht die Fragwürdige Designentscheidung, auch die eckigen Klammern \smalltt{[]} für die Definition eines Arrays \colorbold{vor} die Variable zu schreiben von $\mathtt{L_C}$ übernommen. Es wird so getann, als würde der komplette \colorbold{Datentyp} immer \colorbold{hinter} der Variable stehen: \smalltt{datatype var}.} definiert ist ($\mathtt{struct\enspace st\enspace st\_var;}$), berechnet sich dabei aus der Summe der \colorbold{Größen} der einzelnen \colorbold{Datentypen} $\mathtt{datatype_1\enspace \ldots\enspace datatpye_n}$ der \colorbold{Attribute} $\mathtt{attr_1,\enspace \ldots\enspace attr_n}$ des \colorbold{Structtyps}: $\mathtt{size(st) = \sum^n_{i=1} size(datatype_i)}$.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={5-10,14-19,23-28,41-46}}]{./code_examples/example_struct_decl_def.st}
  \caption{Symboltabelle für die Deklaration eines Structtyps}
  \label{code:symboltabelle_für_die_deklaration_eines_structtyps}
\end{code}

\subsubsection{Initialisierung von Structs}

Die \colorbold{Initialisierung eines Structs} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_initialisierung_von_structs} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={7}}]{./code_examples/example_struct_init.picoc}
  \caption{PicoC-Code für Initialisierung von Structs}
  \label{code:picoc_code_für_initialisierung_von_structs}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_initialisierung_von_structs} wird die \colorbold{Initialisierung eines Structs} \smalltt{struct st1 st = \{.attr1=var, .attr2=\{.attr=\{\{\&var, \&var\}\}\}\};} mithilfe der \colorbold{Komposition} \smalltt{Assign(Alloc(Writeable(), StructSpec(Name('st1')), Name('st')), Struct(\ldots))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={21}}]{./code_examples/example_struct_init.ast}
  \caption{Abstract Syntax Tree für Initialisierung von Structs}
  \label{code:abstract_syntax_tree_für_initialisierung_von_structs}
\end{code}


Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_initialisierung_von_structs} wird die \colorbold{Komposition} \smalltt{Assign(Alloc(Writeable(), StructSpec(Name('st1')), Name('st')), Struct(\ldots))} auf fast dieselbe Weise ausgewertet, wie bei der \colorbold{Initialisierung eines Arrays} in Subkapitel~\ref{sec:initialisierung_von_arrays} daher wird um keine Wiederholung zu betreiben auf Subkapitel~\ref{sec:initialisierung_von_arrays} verwiesen. Um das ganze interressanter zu gestalten wurde das Beispiel in Code~\ref{code:picoc_code_für_initialisierung_von_structs} so gewählt, dass sich daran eine komplexere, mehrstufige Initialisierung mit \colorbold{verschiedenen} Datentypen erklären lässt.

Der \colorbold{Struct-Initializer} Teilbaum \smalltt{Struct([Assign(Name('attr1'), Name('var')), Assign(Name('attr2'), Struct([Assign(Name('attr'), Array([Array([Ref(Name('var')), Ref(Name('var'))])]))]))])}, der beim \colorbold{Struct-Initializer} \colorbold{Container-Knoten} anfängt, wird auf dieselbe Weise nach dem \colorbold{Depth-First-Search} Prinzip von \colorbold{links-nach-rechts} ausgewertet, wie es bei der \colorbold{Initialisierung eines Arrays} in Subkapitel~\ref{sec:initialisierung_von_arrays} bereits erklärt wurde.

Beim \colorbold{Iterieren} über den \colorbold{Teilbaum}, muss beim \colorbold{Struct-Initializer} nur beachtet werden, dass bei den \smalltt{Assign(lhs, exp)}-Knoten, über welche die \colorbold{Attributzuweisung} dargestellt wird (z.B. \smalltt{Assign(Name('attr2'), Struct([Assign(Name('attr'), Array([Array([Ref(Name('var')), Ref(Name('var'))])]))]))}) der Teilbaum beim rechten \smalltt{exp} Attribut weitergeht.

Im Allgemeinen gibt es beim \colorbold{Initialisieren} eines \colorbold{Arrays} oder \colorbold{Structs} im Teilbaum auf der \colorbold{rechten Seite}, der beim jeweiligen obersten \colorbold{Initializer} anfängt immer nur $3$ Fällte, man hat es auf der \colorbold{rechten} Seite entweder mit einem \colorbold{Struct-Initialiser}, einem \colorbold{Array-Initialiser} oder einem \colorbold{Logischen Ausdruck} zu tuen. Bei \colorbold{Array-} und \colorbold{Struct-Initialisier} wird einfach über diese nach dem \colorbold{Depth-First-Search} Schema von \colorbold{links-nach-rechts} iteriert und die Ergebnisse der \colorbold{Logischen Ausdrücken} in den \colorbold{Blättern} auf den \colorbold{Stack} gespeichert. Der Fall, dass ein \colorbold{Logischer Ausdruck} vorliegt erübrigt sich damit.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-14}}]{./code_examples/example_struct_init.picoc_mon}
  \caption{PicoC-Mon Pass für Initialisierung von Structs}
  \label{code:picoc_mon_pass_für_initialisierung_von_structs}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_initialisierung_von_structs} werden die \colorbold{Kompositionen} \smalltt{Exp(exp)}, \smalltt{Ref(exp)} und \smalltt{Assign(Global(Num('1')), Stack(Num('3')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={18-20,22-25,27-30,32-38}}]{./code_examples/example_struct_init.reti_blocks}
  \caption{RETI-Blocks Pass für Initialisierung von Structs}
  \label{code:reti_blocks_pass_für_initialisierung_von_structs}
\end{code}

% Stack und Globale Statische Daten
\subsubsection{Zugriff auf Structattribut}
\label{sec:zugriff_auf_structattribut}
% Formel aus der Vorlesung, wo ist die hier?

Der \colorbold{Zugriff auf ein Structattribut} (z.B. \smalltt{st.y;}) wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_zugriff_auf_structattribut} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_access.picoc}
  \caption{PicoC-Code für Zugriff auf Structattribut}
  \label{code:picoc_code_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_zugriff_auf_structattribut} wird der \colorbold{Zugriff auf ein Structattribut} \smalltt{st.y} mithilfe der \colorbold{Komposition} \smalltt{Exp(Attr(Name('st'), Name('y')))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_access.ast}
  \caption{Abstract Syntax Tree für Zugriff auf Structattribut}
  \label{code:abstract_syntax_tree_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_zugriff_auf_structattribut} wird die Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} auf ähnliche Weise ausgewertet, wie die Komposition, die einen \colorbold{Zugriff auf ein Arrayelement} \smalltt{Exp(Subscr(Name('ar'), Num('0')))} in Subkapitel~\ref{sec:zugriff_auf_arrayindex} darstellt. Daher wird hier, um Wiederholung zu vermeiden nur auf wichtige Aspekte hingewiesen und ansonsnten auf das Subkapitel~\ref{sec:zugriff_auf_arrayindex} verwiesen.

Die Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} wird genauso, wie in Subkapitel~\ref{sec:zugriff_auf_arrayindex} durch Kompositionen ersetzt, die sich in \colorbold{Anfangsteil}~\ref{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}, \colorbold{Mittelteil}~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} und \colorbold{Schlussteil}~\ref{sec:schlussteil_für_die_verschiedenen_derived_datatypes} aufteilen lassen. In diesem Fall sind es \smalltt{Ref(Global(Num('0')))} (\colorbold{Anfangsteil}), \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} (\colorbold{Mittelteil}) und \smalltt{Exp(Stack(Num('1')))} (\colorbold{Schlussteil}). Der \colorbold{Anfangsteil} und \colorbold{Schlussteil} sind genau gleich, wie in Subkapitel~\ref{sec:zugriff_auf_arrayindex}.

Nur für den \colorbold{Mittelteil} wird eine andere Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} gebraucht. Diese Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} erfüllt die Aufgabe die \colorbold{Adresse}, ab der das \colorbold{Attribut} auf das zugegriffen wird anfängt zu berechnen. Dabei wurde die \colorbold{Anfangsadresse} des \colorbold{Structs} indem dieses Attribut liegt bereits vorher auf den \colorbold{Stack} gelegt.

Im Gegensatz zur Komposition \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} beim \colorbold{Zugriff auf einen Arrayindex} in Subkapitel~\ref{sec:zugriff_auf_arrayindex}, muss hier vorher nichts anderes als die \colorbold{Anfangsadresse} des \colorbold{Structs} auf dem \colorbold{Stack} liegen. Das \colorbold{Structattribut} auf welches zugegriffen wird steht bereits in der Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))}, nämlich \smalltt{Name('y')}. Den \colorbold{Structtyp}, dem dieses Attribut gehört, kann man aus dem \textcolor{gray!90!black}{versteckten Attribut} \smalltt{datatype} herauslesen. Das \textcolor{gray!90!black}{versteckte Attribut} wird während des Kompiliervorgangs im \colorbold{PiocC-Mon Pass} dem \colorbold{Container-Knoten} \smalltt{Ref(exp, \textcolor{gray!90!black}{datatype})} angehängt.

  % Die \colorbold{Größe} einer Variable \smalltt{st\_var}, die ihm \smalltt{size}-Feld des \colorbold{Symboltabelleneintrags} eingetragen ist und mit dem \colorbold{Structtyp} $\mathtt{struct\enspace st\enspace \{datatype_1\enspace attr_1;\enspace\ldots\enspace datatype_n\enspace attr_n;\};}$\footnote{Hier wird es der Einfachheit halber so dargestellt, als hätte die Programmiersprache $L_{PicoC}$ nicht die Fragwürdige Designentscheidung, auch die eckigen Klammern \smalltt{[]} für die Definition eines Arrays \colorbold{vor} die Variable zu schreiben von $\mathtt{L_C}$ übernommen. Es wird so getann, als würde der komplette \colorbold{Datentyp} immer \colorbold{hinter} der Variable stehen: \smalltt{datatype var}.} definiert ist ($\mathtt{struct\enspace st\enspace st\_var;}$), berechnet sich dabei aus der Summe der \colorbold{Größen} der einzelnen \colorbold{Datentypen} $\mathtt{datatype_1\enspace \ldots\enspace datatpye_n}$ der \colorbold{Attribute} $\mathtt{attr_1,\enspace \ldots\enspace attr_n}$ des \colorbold{Structtyps}: $\mathtt{size(st) = \sum^n_{i=1} size(datatype_i)}$.

\begin{Special_Paragraph}
  Die Berechnung der \colorbold{Adresse}, für eine Aneinanderreihung von \colorbold{Zugriffen auf Structattributte} $\mathtt{st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n}}$ mehrerer \colorbold{Structs} $\mathtt{struct\enspace st_i\enspace st\_var_i}$ unterschiedlicher \colorbold{Structtypen} $\mathtt{struct\enspace st_i\enspace \{datatype_{i, 1}\enspace attr_{i, 1};\enspace\ldots\enspace datatype_{i, m}\enspace attr_{i, m};\}}$, kann mittels der Formel~\ref{eq:adresse_von_structattribut}:

  \begin{equation}
    \mathtt{ref(st\_var_1.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n}) = ref(st\_var_1) + \sum_{i=1}^{n}\sum_{k=1}^{j_i - 1} \operatorname{size}(datatype_{i, k})} \\
    \label{eq:adresse_von_structattribut}
  \end{equation}
  aus der Betriebssysteme Vorlesung\footcite{scholl_betriebssysteme_2020} berechnet werden.\footnote{\smalltt{ref(exp)} steht dabei für das Schreiben der \colorbold{Adresse} von \smalltt{exp} auf den Stack, wobei \smalltt{exp} z.B. \smalltt{st\_var.attr} sein könnte.}\footnote{Die \colorbold{äußere Schleife} iteriert nacheinander über die \colorbold{Zugriffe auf Structattribute}. Die \colorbold{innere Schleife} iteriert über alle \colorbold{Attribute} des momentan betrachteten \colorbold{Structtyps} $\mathtt{st_i}$, die vor dem Attribut mit der Nummer $\mathtt{j_i}$ liegen.}

  Die Kompositionen \smalltt{Ref(Global(Num('0')))} repräsentiert dabei den Summanden $\mathtt{ref(st\_var_1)}$ in der Formel.

  Der Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} repräsentiert dabei einen Summanden $\mathtt{\sum_{k=1}^{j_i\;\mid\; attr_{i,j_i}} \operatorname{size}(datatype_{i, k})}$ in der Formel.

Die Komposition \smalltt{Exp(Stack(Num('1')))} repräsentiert dabei das Lesen des \colorbold{Inhalts} $\mathtt{M\left[ref(st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n})\right]}$ der Speicherzelle an der finalen \colorbold{Adresse}  $\mathtt{ref(st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n})}$.

In Unterkapitel~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} wird eine allgemeine Formel für \colorbold{Zugriffe} auf \colorbold{Structattribute}, \colorbold{Arrayelemente} und \colorbold{Pointer} erklärt, die auf der obigen Formel~\ref{eq:adresse_von_structattribut} und der Formel~\ref{eq:adresse_von_arrayelement} aufbaut.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-14}}]{./code_examples/example_struct_attr_access.picoc_mon}
  \caption{PicoC-Mon Pass für Zugriff auf Structattribut}
  \label{code:picoc_mon_pass_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_zugriff_auf_structattribut} werden die \colorbold{Kompositionen} \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} und \smalltt{Exp(Stack(Num('1')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-27,29-31,33-35}}]{./code_examples/example_struct_attr_access.reti_blocks}
  \caption{RETI-Blocks Pass für Zugriff auf Structattribut}
  \label{code:reti_blocks_pass_für_zugriff_auf_structattribut}
\end{code}

\subsubsection{Zuweisung an Structattribut}
Die \colorbold{Zuweisung an ein Structattribut} (z.B. \smalltt{st.y = 42;}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_zuweisung_an_structattribut} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_assignment.picoc}
  \caption{PicoC-Code für Zuweisung an Structattribut}
  \label{code:picoc_code_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{Abstact Syntax Tree} wird eine  \colorbold{Zuweisung an ein Structattribut} (z.B. \smalltt{st.y = 42;}) durch die Komposition \smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_assignment.ast}
  \caption{Abstract Syntax Tree für Zuweisung an Structattribut}
  \label{code:abstract_syntax_tree_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_zuweisung_an_structattribut} wird die Komposition \smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))} auf ähnliche Weise ausgewertet, wie die Komposition, die einen \colorbold{Zugriff auf ein Arrayelement} \smalltt{ Assign(Subscr(Name('ar'), Num('2')), Num('42'))} in Subkapitel~\ref{sec:zuweisung_an_arrayindex} darstellt. Daher wird hier, um Wiederholung zu vermeiden nur auf wichtige Aspekte hingewiesen und ansonsnten auf das Unterkapitel~\ref{sec:zuweisung_an_arrayindex} verwiesen.

Im Gegensatz zum Vorgehen in Unterkapitel~\ref{sec:zuweisung_an_arrayindex} muss hier für das Auswerten des \colorbold{linken} Container-Knoten \smalltt{Attr(Name('st'), Name('y'))} von \smalltt{\smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))}} wie in Subkapitel~\ref{sec:zugriff_auf_structattribut} vorgegangen werden.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-15}}]{./code_examples/example_struct_attr_assignment.picoc_mon}
  \caption{PicoC-Mon Pass für Zuweisung an Structattribut}
  \label{code:picoc_mon_pass_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_zuweisung_an_structattribut} werden die \colorbold{Kompositionen} \smalltt{Exp(Num('42'))}, \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} und \smalltt{Assign(Stack(Num('1')), Stack(Num('2')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-26,28-31,33-35,37-40}}]{./code_examples/example_struct_attr_assignment.reti_blocks}
  \caption{RETI-Blocks Pass für Zuweisung an Structattribut}
  \label{code:reti_blocks_pass_für_zuweisung_an_structattribut}
\end{code}

\subsection{Umsetzung des Zugriffs auf Derived Datatypes im Allgemeinen}
In den Unterkapiteln \ref{sec:umsetzung_von_pointern}, \ref{sec:umsetzung_von_arrays} und \ref{sec:umsetzung_von_structs} fällt auf, dass der \colorbold{Zugriff} auf \colorbold{Elemente} / \colorbold{Attribute} der in diesen Kapiteln beschriebenen Datentypen (\colorbold{Pointer}, \colorbold{Array} und \colorbold{Struct}) sehr ähnlich abläuft. Es lässt sich ein allgemeines Vorgehen, bestehend aus einem \colorbold{Anfangsteil}, \colorbold{Mittelteil} und \colorbold{Schlussteil} darin erkennen.

Dieses Vorgehen ist in Abbildung~\ref{fig:zugriff_auf_derived_datatypes_veranschaulicht} veranschaulicht. Dieses Vorgehen erlaubt es auch gemischte Ausdrücke zu schreiben, in denen die verschiedenen \colorbold{Zugriffsarten} für \colorbold{Elemente} / \colorbold{Attribute} der Datenypen \colorbold{Pointer}, \colorbold{Array} und \colorbold{Struct} gemischt sind (z.B. \smalltt{(*st\_var.ar)[0]}).

Dies ist möglich, indem im \colorbold{Mittelteil} je nachdem, ob das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} des \smalltt{Ref(exp)}-Container-Knotens ein \smalltt{ArrayDecl(nums, datatype)}, ein \smalltt{PntrDecl(num, datatype)} oder \smalltt{StructSpec(name)} beinhaltet, ein anderer \colorbold{RETI-Code} generiert wird, der die \colorbold{Startadresse} eines gewünschten \colorbold{Pointerelmements}, \colorbold{Arrayelements} oder \colorbold{Structattributs} berechhnet.

Würde man bei einem \smalltt{Subscr(Name('var'), exp2)} den Datentyp der Variable \smalltt{Name('var')} von \smalltt{ArrayDecl(nums, IntType())} zu \smalltt{PointerDecl(num, IntType())} ändern, müsste nur der \colorbold{Mittelteil} ausgetauscht werden. \colorbold{Anfangsteil} und \colorbold{Schlussteil} bleiben unverändert.

Der \colorbold{Anfangsteil} ist die Komposition \smalltt{Ref(Name('var'))} dafür zuständig die \colorbold{Startadresse} der Variablen \smalltt{Name('var')} auf den Stack zu schreiben und je nachdem, ob diese Variable in den \colorbold{Globalen Statischen Daten} oder auf dem \colorbold{Stackframe} liegt einen anderen \colorbold{RETI-Code} zu generieren.

Im \colorbold{Schlussteil} wird mit der Komposition \smalltt{Exp(Stack(Num('1')))}, wenn das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} am Ende ein \smalltt{CharType()}, \smalltt{IntType()}, \smalltt{PntrDecl} oder \smalltt{StructType()} ist ein entsprechender \colorbold{RETI-Code} generiert, bei einem \smalltt{ArrayDecl()} wird kein weiterer \colorbold{RETI-Code} generiert. Üblicherweise wollen die m

Im Folgenden werden anhand mehrerer Beispiele die einzelnen Abschnitte \colorbold{Anfangsteil}, \colorbold{Mittelteil} und \colorbold{Schlussteil} bei der Kompilierung von \colorbold{Zugriffen auf Arrayelemente}, \colorbold{Structattribute} und \colorbold{Pointer} bei gemischten Ausdrücken, wie \smalltt{(*st\_first.ar)[0];} einzeln isoliert betrachtet und erläutert.

% Im \colorbold{Unterkapitel}~\ref{sec:zugriff_auf_structattribut} hat man bereits gemerkt, dass das Vorgehen für den \colorbold{Zugriff auf ein Structattribut} sehr ähnlich zum dem Vorgehen zum \colorbold{Zugriff auf einen Arrayindex} in Unterkapitel~\ref{sec:zugriff_auf_arrayindex} ist. Im \colorbold{Unterkapitel}~\ref{sec:zugriff_auf_structattribut} wurde sogar bei der Erklärung sogar auf das Unterkapitel~\ref{Unterkapitel~\ref{sec:zugriff_auf_arrayindex}} verwiesen.

\newpage

\begin{figure}[H]
  \centering
  \begin{File}[remember as=input]
    Start
  \end{File}
  \vspace{0.6cm}
  \begin{Code_Frame}[remember as=anfangsteil]{Anfangsteil}
    \codebox[title=Variable vom Stackframe, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=A]{./code_examples/ubersicht_anfangsteil_global.special}
    \hfill
    \codebox[title=Variable aus Globalen Statischen Daten, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=A]{./code_examples/ubersicht_anfangsteil_stackframe.special}
  \end{Code_Frame}
  \vspace{0.6cm}
  \begin{Code_Frame}[remember as=mittelteil]{Mittelteil}
    \codebox[title=Arrayindexzugriff auf Array, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_array.special}
    \hfill
    \codebox[title=Arrayindexzugriff auf Pointer, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_pntr.special}
    \hfill
    \codebox[title=Structattributzugriff auf Struct, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_struct.special}
  \end{Code_Frame}
  \vspace{0.8cm}
  \begin{Code_Frame}[remember as=schlussteil]{Schlussteil}
    \codebox[title={Letzer Datentyp ist Struct, Pointer oder Primitiver Datentyp}, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=S]{./code_examples/ubersicht_schlussteil_struct_int_char.special}
    \hfill
    \codebox[title=Letzer Datentyp ist Array, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=S]{./code_examples/ubersicht_schlussteil_array_pntr.special}
  \end{Code_Frame}
  \vspace{0.8cm}
  \begin{File}[remember as=output, hbox]
    Ende
  \end{File}
  \begin{tikzpicture}[overlay,remember picture,line width=1mm,draw=PrimaryColor]
  \draw[->] (input.south) to node[right, align=center] {\colorbold{nichts} momentan \colorbold{relevantes} auf dem Stack} (anfangsteil.north);
  \draw[->] (anfangsteil.south) to node[right, align=center] {\colorbold{Startadresse} der Variable auf dem Stack} (mittelteil.north);
  \draw [->] (mittelteil.east)arc(-160:160:0.8) node[right, align=center] {siehe \footnotemark};
  \draw[->] (mittelteil.south) to node[right, align=center] {\colorbold{Startadresse} / \colorbold{Adresse} eines \colorbold{Pointerelements},\\ \colorbold{Arrayelements} oder \colorbold{Structattributes} auf dem Stack} (schlussteil.north);
  \draw[->] (schlussteil.south) to node[right, align=center] {\colorbold{Inhalt} der Speicherzelle an der berechneten\\ \colorbold{Adresse} oder berechnete \colorbold{Adresse} selbst} (output.north);
  \end{tikzpicture}
  \caption{Allgemeine Veranschaulichung des Zugriffs auf Derived Datatypes}
  \label{fig:zugriff_auf_derived_datatypes_veranschaulicht}
\end{figure}

% https://tex.stackexchange.com/questions/107603/create-a-footnote-in-node-in-a-tikzpicture
\footnotetext{\colorbold{Startadresse} / \colorbold{Adresse} eines \colorbold{Pointerelements}, \colorbold{Arrayelements} oder \colorbold{Structattributes} auf dem Stack.}

Implementieren lässt sich dieses Vorgehen, indem beim Antreffen eines \smalltt{Subscr(exp1, exp2)} oder \smalltt{Attr(exp, name)} Ausdrucks ein \smalltt{Exp(Stack(Num('1')))} an die Spitze einer \colorbold{Liste der generierten Ausdrücke} gesetzt wird und der Ausdruck selbst als \smalltt{exp}-Attribut des \smalltt{Ref(exp)}-Knotens gesetzt wird und hinter den \smalltt{Exp(Stack(Num('1')))} Knoten in der Liste eingefügt wird.

Es wird solange dem jeweiligen \smalltt{exp1} des \smalltt{Subscr(exp1, exp2)}-Knoten, dem \smalltt{exp} des \smalltt{Attr(exp, name)} Knoten oder dem \smalltt{exp} des \smalltt{Ref(exp)}-Knotens gefolgt und der jeweilige \colorbold{Container-Knoten} selbst in ein \smalltt{Ref(exp)} eingesetzt und hinten in die Liste der generierten Ausdrücke eingefügt, bis man bei einem \smalltt{Name(name)} ankommt. Der \smalltt{Name(name)}-Knoten wird zu einem \smalltt{Ref(Global(num))} oder \smalltt{Ref(Stackframe(num))} umgewandelt und ebenfalls ganz hinten in die \colorbold{Liste der generierten Ausdrücke} eingefügt.

Parallel wird eine Liste der \smalltt{Ref(exp)}-Knoten geführt, deren \textcolor{gray!90!black}{versteckte Attribute} \smalltt{datatype} und \smalltt{error\_data} die entsprechenden Informationen zugewiesen bekommen müssen. Sobald man beim \smalltt{Name(name)}-Knoten angekommen ist und mithilfe dieses in der \colorbold{Symboltabelle} den \colorbold{Dantentyp} der Variable nachsehen kann, wird der \colorbold{Datentyp} der Variable nun ebenfalls, wie die Ausdrücke \smalltt{Subscr(exp1, exp2)} und \smalltt{Attr(exp, name)} schrittweise durchiteriert und dem jeweils nächsten \smalltt{datatype}-Attribut gefolgt werden. Das \colorbold{Iterieren} über den \colorbold{Datentyp} wird solange durchgeführt, bis alle \smalltt{Ref(exp)}-Knoten ihren im jeweiligen \colorbold{Kontext} vorliegenden \colorbold{Datenetyp} in ihrem \smalltt{datatype}-Attribut zugewiesen bekommen haben. Alles andere führt zu einer \colorbold{Fehlermeldung}, für die das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{error\_data} genutzt wird.\footnote{Man könnte diese Implementierung gut mit dem \colorbold{Auseinanderrollen} und \colorbold{Wieder-Einrollen} einer \colorbold{Schnecke} vergleichen.}

\subsubsection{Anfangsteil für Globale Statische Daten und Stackframe}
\label{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}

% Stack und Globale Statische Daten, unterschieldihe Berechnung der Adressen
% unterschiedliche Adressberechnung
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={6, 12}}]{./code_examples/example_derived_dts_introduction_part.picoc}
  \caption{PicoC-Code für den Anfangsteil}
  \label{code:picoc_code_einleitungsteil}
\end{code}

% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={17, 26}}]{./code_examples/example_derived_dts_introduction_part.ast}
  \caption{Abstract Syntax Tree für den Anfangsteil}
  \label{code:abstract_syntax_tree_einleitungsteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10,19}}]{./code_examples/example_derived_dts_introduction_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Anfangsteil}
  \label{code:picoc_mon_pass_einleitungsteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-13,24-26}}]{./code_examples/example_derived_dts_introduction_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Anfangsteil}
  \label{code:reti_blocks_pass_einleitungsteil}
\end{code}

\subsubsection{Mittelteil für die verschiedenen Derived Datatypes}
\label{sec:mittelteil_für_die_verschiedenen_derived_datatypes}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={6}}]{./code_examples/example_derived_dts_main_part.picoc}
  \caption{PicoC-Code für den Mittelteil}
  \label{code:picoc_code_mittelteil}
\end{code}

% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_derived_dts_main_part.ast}
  \caption{Abstract Syntax Tree für den Mittelteil}
  \label{code:abstract_syntax_tree_mittelteil}
\end{code}

\begin{Special_Paragraph}
  Die Berechnung der \colorbold{Adresse}, für eine Folge von \colorbold{Zugriffen auf Structattributte} $\mathtt{st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n}}$ mehrerer \colorbold{Structs} $\mathtt{struct\enspace st_i\enspace st\_var_i}$ unterschiedlicher \colorbold{Structtypen} $\mathtt{struct\enspace st_i\enspace \{datatype_{i, 1}\enspace attr_{i, 1};\enspace\ldots\enspace datatype_{i, m}\enspace attr_{i, m};\};}$, kann mittels der Formel~\ref{eq:adresse_von_structattribut}:

  \begin{equation}
    \mathtt{ref(st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n}) = ref(st_1) + \sum_{i=1}^{n}\sum_{k=1}^{j_i\;\mid\; attr_{i,j_i}} \operatorname{size}(datatype_{i, k})} \\
    \label{eq:adresse_von_structattribut}
  \end{equation}
  aus der Betriebssysteme Vorlesung\footcite{scholl_betriebssysteme_2020} berechnet werden\footnote{\smalltt{ref(exp)} steht dabei für die Berechnung der \colorbold{Adresse} von \smalltt{exp}, wobei \smalltt{exp} z.B. \smalltt{ar[3][2]} sein könnte.}.

  Die Kompositionen \smalltt{Ref(Global(Num('0')))} repräsentiert dabei den Summanden $\mathtt{ref(st_1)}$ in der Formel.

  Der Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} repräsentiert dabei einen Summanden $\mathtt{\sum_{k=1}^{j_i\;\mid\; attr_{i,j_i}} \operatorname{size}(datatype_{i, k})}$ in der Formel.

Die Komposition \smalltt{Exp(Stack(Num('1')))} repräsentiert dabei das Lesen des \colorbold{Inhalts} $\mathtt{M\left[ref(st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n})\right]}$ der Speicherzelle an der finalen \colorbold{Adresse}  $\mathtt{ref(st.attr_{1, j_1}\enspace\ldots\enspace .attr_{n, j_n})}$.

In Unterkapitel~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} wird eine allgemeine Formel für \colorbold{Zugriffe} auf \colorbold{Structattribute}, \colorbold{Arrayelemente} und \colorbold{Pointer} erklärt.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-19}}]{./code_examples/example_derived_dts_main_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Mittelteil}
  \label{code:picoc_mon_pass_mittelteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={33-35,37-39,41-47,49-51,53-58}}]{./code_examples/example_derived_dts_main_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Mittelteil}
  \label{code:reti_blocks_pass_mittelteil}
\end{code}
% spezielles Vorgehen bei PntrDecl

\subsubsection{Schlussteil für die verschiedenen Derived Datatypes}
\label{sec:schlussteil_für_die_verschiedenen_derived_datatypes}
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={10-12}}]{./code_examples/example_derived_dts_final_part.picoc}
  \caption{PicoC-Code für den Schlussteil}
  \label{code:picoc_code_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={19-21}}]{./code_examples/example_derived_dts_final_part.ast}
  \caption{Abstract Syntax Tree für den Schlussteil}
  \label{code:abstract_syntax_tree_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={22,27,32}}]{./code_examples/example_derived_dts_final_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Schlussteil}
  \label{code:picoc_mon_pass_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={55,74-76,95}}]{./code_examples/example_derived_dts_final_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Schlussteil}
  \label{code:reti_blocks_pass_schlussteil}
\end{code}

% Umgang, wenn Datentyp abrubt aufhört am Ende
