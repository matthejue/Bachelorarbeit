%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1_Tables_DT_AST.tex,
% ./Implementierung2_Pntr_Array.tex,
% ./Implementierung4_Fun.tex,
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Structs}
\label{sec:umsetzung_von_structs}
\subsubsection{Deklaration und Definition von Structtypen}

Die \colorbold{Deklaration} eines neuen \colorbold{Structtyps} (z.B. \smalltt{struct st \{int len; int ar[2];\}}) und die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp} (z.B. \smalltt{struct st st\_var;}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_die_deklaration_eines_structtyps} erläutert.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,4}}]{./code_examples/example_struct_decl_def.picoc}
  \caption{PicoC-Code für die Deklaration eines Structtyps}
  \label{code:picoc_code_für_die_deklaration_eines_structtyps}
\end{code}

Bevor irgendwas definiert werden kann, muss erstmal ein \colorbold{Structtyp} deklariert werden. Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} wird die \colorbold{Deklaration eines Structtyps} \smalltt{struct st \{int len; int ar[2];\}} durch die Komposition \smalltt{StructDecl(Name('st'), [Alloc(Writeable(), IntType('int'), Name('len')) Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} dargestellt.

Die \colorbold{Definition} einer Variable mit diesem \colorbold{Structtyp}  \smalltt{struct st st\_var;}  wird durch die Komposition \smalltt{Alloc(Writeable(), StructSpec(Name('st')), Name('st\_var'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,15}}]{./code_examples/example_struct_decl_def.ast}
  \caption{Abstract Syntax Tree für die Deklaration eines Structtyps}
  \label{code:abstract_syntax_tree_für_die_deklaration_eines_structtyps}
\end{code}

Für den \colorbold{Structtyp} selbst wird in der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_die_deklaration_eines_structtyps} dargestellt ist ein Eintrag mit dem \colorbold{Schlüssel} \smalltt{st} erstellt. Die Felder dieses Eintrags \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{position} und \smalltt{size} sind wie üblich belegt, allerdings sind in dem \smalltt{value\_address}-Feld die Attribute des \colorbold{Structtyps} \smalltt{[Name('len@st'), Name('ar@st')]} aufgelistet, sodass man über den \colorbold{Structtyp} \smalltt{st} die  \colorbold{Attribute} des Structtyps in der  \colorbold{Symboltabelle} nachschlagen kann. Die Schlüssel der \colorbold{Attribute} haben einen \colorbold{Suffix} \smalltt{@st} angehängt, der eine Art \colorbold{Scope} innerhalb des \colorbold{Structtyps} für seine Attribut darstellt. Es gilt foglich, dass \colorbold{innerhalb} eines \colorbold{Structtyps} zwei Attribute nicht gleich benannt werden können, aber dafür zwei \colorbold{unterschiedliche} \colorbold{Structtypen} ihre Attribute gleich benennen können.

Jedes der \colorbold{Attribute} \smalltt{[Name('len@st'), Name('ar@st')]} erhält auch einen eigenen Eintrag in der \colorbold{Symboltabelle}, wobei die Felder \smalltt{type\_qualifier}, \smalltt{datatype},  \smalltt{name}, \smalltt{value\_address}, \smalltt{position} und \smalltt{size} wie üblich belegt werden. Die Felder \smalltt{type\_qualifier}, \smalltt{datatype} und \smalltt{name} werden z.B. bei \smalltt{Name('ar@st')} mithilfe der Attribute von \smalltt{Alloc(Writeable(), ArrayDecl([Num('2')], IntType('int')), Name('ar'))])} belegt.

Für die \colorbold{Definition} einer Variable \smalltt{st\_var@main} mit diesem \colorbold{Structtyp} \smalltt{st} wird ein Eintrag in der \colorbold{Symboltabelle} angelegt. Das \smalltt{datatyp}-Feld enthält dabei den Namen des \colorbold{Structtyps} als Komposition \smalltt{StructSpec(Name('st'))}, wodurch jederzeit alle wichtigen Informationen zu diesem \colorbold{Structyp}\footnote{Wie z.B. vor allem die \colorbold{Größe} bzw. \colorbold{Anzahl an Speicherzellen}, die dieser \colorbold{Structtyp} einnimmt.} und seinen \colorbold{Attributen} in der  \colorbold{Symboltabelle} nachgeschlagen werden können.

% https://tex.stackexchange.com/questions/1959/allowing-line-break-at-in-inline-math-mode
\begin{Special_Paragraph}
  Die \colorbold{Größe} einer Variable \smalltt{st\_var}, die ihm \smalltt{size}-Feld des \colorbold{Symboltabelleneintrags} eingetragen ist und mit dem \colorbold{Structtyp} $\mathtt{struct\enspace st\enspace \{datatype_1\enspace attr_1;\enspace\ldots\enspace datatype_n\enspace attr_n;\};}$\footnote{Hier wird es der Einfachheit halber so dargestellt, als hätte die Programmiersprache $L_{PicoC}$ nicht die Fragwürdige Designentscheidung, auch die eckigen Klammern \smalltt{[]} für die Definition eines Arrays \colorbold{vor} die Variable zu schreiben von $\mathtt{L_C}$ übernommen. Es wird so getann, als würde der komplette \colorbold{Datentyp} immer \colorbold{hinter} der Variable stehen: \smalltt{datatype var}.} definiert ist ($\mathtt{struct\enspace st\enspace st\_var;}$), berechnet sich dabei aus der Summe der \colorbold{Größen} der einzelnen \colorbold{Datentypen} $\mathtt{datatype_1\enspace \ldots\enspace datatpye_n}$ der \colorbold{Attribute} $\mathtt{attr_1,\enspace \ldots\enspace attr_n}$ des \colorbold{Structtyps}: $\mathtt{size(st) = \sum^n_{i=1} size(datatype_i)}$.
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={5-10,14-19,23-28,41-46}}]{./code_examples/example_struct_decl_def.st}
  \caption{Symboltabelle für die Deklaration eines Structtyps}
  \label{code:symboltabelle_für_die_deklaration_eines_structtyps}
\end{code}

\subsubsection{Initialisierung von Structs}

Die \colorbold{Initialisierung eines Structs} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_initialisierung_von_structs} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={7}}]{./code_examples/example_struct_init.picoc}
  \caption{PicoC-Code für Initialisierung von Structs}
  \label{code:picoc_code_für_initialisierung_von_structs}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_initialisierung_von_structs} wird die \colorbold{Initialisierung eines Structs} \smalltt{struct st1 st = \{.attr1=var, .attr2=\{.attr=\{\{\&var, \&var\}\}\}\}} mithilfe der \colorbold{Komposition} \smalltt{Assign(Alloc(Writeable(), StructSpec(Name('st1')), Name('st')), Struct(\ldots))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={21}}]{./code_examples/example_struct_init.ast}
  \caption{Abstract Syntax Tree für Initialisierung von Structs}
  \label{code:abstract_syntax_tree_für_initialisierung_von_structs}
\end{code}


Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_initialisierung_von_structs} wird die \colorbold{Komposition} \smalltt{Assign(Alloc(Writeable(), StructSpec(Name('st1')), Name('st')), Struct(\ldots))} auf fast dieselbe Weise ausgewertet, wie bei der \colorbold{Initialisierung eines Arrays} in Subkapitel~\ref{sec:initialisierung_von_arrays} daher wird um keine Wiederholung zu betreiben auf Subkapitel~\ref{sec:initialisierung_von_arrays} verwiesen. Um das ganze interressanter zu gestalten wurde das Beispiel in Code~\ref{code:picoc_code_für_initialisierung_von_structs} so gewählt, dass sich daran eine komplexere, mehrstufige Initialisierung mit \colorbold{verschiedenen} Datentypen erklären lässt.

Der \colorbold{Struct-Initializer} Teilbaum \smalltt{Struct([Assign(Name('attr1'), Name('var')), Assign(Name('attr2'), Struct([Assign(Name('attr'), Array([Array([Ref(Name('var')), Ref(Name('var'))])]))]))])}, der beim \colorbold{Struct-Initializer} \colorbold{Container-Knoten} anfängt, wird auf dieselbe Weise nach dem \colorbold{Depth-First-Search} Prinzip von \colorbold{links-nach-rechts} ausgewertet, wie es bei der \colorbold{Initialisierung eines Arrays} in Subkapitel~\ref{sec:initialisierung_von_arrays} bereits erklärt wurde.

Beim \colorbold{Iterieren} über den \colorbold{Teilbaum}, muss beim \colorbold{Struct-Initializer} nur beachtet werden, dass bei den \smalltt{Assign(lhs, exp)}-Knoten, über welche die \colorbold{Attributzuweisung} dargestellt wird (z.B. \smalltt{Assign(Name('attr2'), Struct([Assign(Name('attr'), Array([Array([Ref(Name('var')), Ref(Name('var'))])]))]))}) der Teilbaum beim rechten \smalltt{exp} Attribut weitergeht.

Im Allgemeinen gibt es beim \colorbold{Initialisieren} eines \colorbold{Arrays} oder \colorbold{Structs} im Teilbaum auf der \colorbold{rechten Seite}, der beim jeweiligen obersten \colorbold{Initializer} anfängt immer nur $3$ Fällte, man hat es auf der \colorbold{rechten} Seite entweder mit einem \colorbold{Struct-Initialiser}, einem \colorbold{Array-Initialiser} oder einem \colorbold{Logischen Ausdruck} zu tuen. Bei \colorbold{Array-} und \colorbold{Struct-Initialisier} wird einfach über diese nach dem \colorbold{Depth-First-Search} Schema von \colorbold{links-nach-rechts} iteriert und die Ergebnisse der \colorbold{Logischen Ausdrücken} in den \colorbold{Blättern} auf den \colorbold{Stack} gespeichert. Der Fall, dass ein \colorbold{Logischer Ausdruck} vorliegt erübrigt sich damit.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-14}}]{./code_examples/example_struct_init.picoc_mon}
  \caption{PicoC-Mon Pass für Initialisierung von Structs}
  \label{code:picoc_mon_pass_für_initialisierung_von_structs}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_initialisierung_von_structs} werden die \colorbold{Kompositionen} \smalltt{Exp(exp)}, \smalltt{Ref(exp)} und \smalltt{Assign(Global(Num('1')), Stack(Num('3')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={18-20,22-25,27-30,32-38}}]{./code_examples/example_struct_init.reti_blocks}
  \caption{RETI-Blocks Pass für Initialisierung von Structs}
  \label{code:reti_blocks_pass_für_initialisierung_von_structs}
\end{code}

% Stack und Globale Statische Daten
\subsubsection{Zugriff auf Structattribut}
\label{sec:zugriff_auf_structattribut}
% Formel aus der Vorlesung, wo ist die hier?

Der \colorbold{Zugriff auf ein Structattribut} (z.B. \smalltt{st.y}) wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_zugriff_auf_structattribut} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_access.picoc}
  \caption{PicoC-Code für Zugriff auf Structattribut}
  \label{code:picoc_code_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_zugriff_auf_structattribut} wird der \colorbold{Zugriff auf ein Structattribut} \smalltt{st.y} mithilfe der \colorbold{Komposition} \smalltt{Exp(Attr(Name('st'), Name('y')))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_access.ast}
  \caption{Abstract Syntax Tree für Zugriff auf Structattribut}
  \label{code:abstract_syntax_tree_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_zugriff_auf_structattribut} wird die Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} auf ähnliche Weise ausgewertet, wie die Komposition, die einen \colorbold{Zugriff auf ein Arrayelement} \smalltt{Exp(Subscr(Name('ar'), Num('0')))} in Subkapitel~\ref{sec:zugriff_auf_arrayindex} darstellt. Daher wird hier, um Wiederholung zu vermeiden nur auf wichtige Aspekte hingewiesen und ansonsnten auf das Subkapitel~\ref{sec:zugriff_auf_arrayindex} verwiesen.

Die Komposition \smalltt{Exp(Attr(Name('st'), Name('y')))} wird genauso, wie in Subkapitel~\ref{sec:zugriff_auf_arrayindex} durch Kompositionen ersetzt, die sich in \colorbold{Anfangsteil}~\ref{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}, \colorbold{Mittelteil}~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} und \colorbold{Schlussteil}~\ref{sec:schlussteil_für_die_verschiedenen_derived_datatypes} aufteilen lassen. In diesem Fall sind es \smalltt{Ref(Global(Num('0')))} (\colorbold{Anfangsteil}), \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} (\colorbold{Mittelteil}) und \smalltt{Exp(Stack(Num('1')))} (\colorbold{Schlussteil}). Der \colorbold{Anfangsteil} und \colorbold{Schlussteil} sind genau gleich, wie in Subkapitel~\ref{sec:zugriff_auf_arrayindex}.

Nur für den \colorbold{Mittelteil} wird eine andere Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} gebraucht. Diese Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} erfüllt die Aufgabe die \colorbold{Adresse}, ab der das \colorbold{Attribut} auf das zugegriffen wird anfängt zu berechnen. Dabei wurde die \colorbold{Anfangsadresse} des \colorbold{Structs} indem dieses Attribut liegt bereits vorher auf den \colorbold{Stack} gelegt.

Im Gegensatz zur Komposition \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} beim \colorbold{Zugriff auf einen Arrayindex} in Subkapitel~\ref{sec:zugriff_auf_arrayindex}, muss hier vorher nichts anderes als die \colorbold{Anfangsadresse} des \colorbold{Structs} auf dem \colorbold{Stack} liegen. Das \colorbold{Structattribut} auf welches zugegriffen wird steht bereits in der Komposition \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))}, nämlich \smalltt{Name('y')}. Den \colorbold{Structtyp}, dem dieses Attribut gehört, kann man aus dem \textcolor{gray!90!black}{versteckten Attribut} \smalltt{datatype} herauslesen. Das \textcolor{gray!90!black}{versteckte Attribut} wird während des Kompiliervorgangs im \colorbold{PiocC-Mon Pass} dem \colorbold{Container-Knoten} \smalltt{Ref(exp, \textcolor{gray!90!black}{datatype})} angehängt.

\begin{Special_Paragraph}
  Sei $\mathtt{location_{i}}$ ein Knotes eines \colorbold{entarteten Baumes} (siehe Definition~\ref{def:entarteter_baum} und Abbildung~\ref{eq:location_tree}), dessen Wurzel $\mathtt{location_{1}}$ ist. Dabei steht \smalltt{i} für eine \colorbold{Ebene} des entarteten Baumes. Die Knoten des entarteten Baumes lassen sich \colorbold{Startadressen} $\mathtt{ref(location_{i})}$ von Speicherbereichen $\mathtt{ref(location_{i})\enspace\ldots\enspace ref(location_{i}) + size(location_{i})}$ im Hauptspeicher zuordnen, wobei gilt, dass $\mathtt{ref(location_{i}) \leq ref(location_{i+1}) < ref(location_{i}) + size(location_{i})}$.\footnote{Es ist ein Baum, der \colorbold{nur} die \colorbold{Datentypen} als Knoten enthält, auf die \colorbold{zugegriffen} wird.}\footnote{\smalltt{ref(location)} steht dabei für das Schreiben der \colorbold{Adresse} von \smalltt{location} auf den Stack.}

  Sei $\mathtt{location_{i, k}}$ ein beliebiges \colorbold{Element / Attribut} des Datentyps $\mathtt{location_i}$. Dabei gilt: $\mathtt{ref(location_{i, k}) < ref(location_{i, k+1})}$.

  Sei $\mathtt{location_{i, idx_i}}$ ein beliebiges \colorbold{Element / Attribut} des Datentyps $\mathtt{location_i}$, sodass gilt: $\mathtt{location_{i, idx_i} = location_{i+1}}$.

  \begin{figure}[H]
    \centering
    \begin{equation}
      \begin{tikzpicture}[baseline=(current  bounding  box.center)]
        \graph [grow right=2.3cm, simple] {
          "location1"[as=$\mathtt{location_1}$] -> {
            "location11"[as=$\mathtt{location_{1, 1}}$, gray!90!black],
            "...k"[as=$\ldots$, gray!90!black],
            "location1k"[as=$\mathtt{location_{1, k}}$, gray!90!black],
            "...k2"[as=$\ldots$, gray!90!black],
            "location1idx"[as=$\mathtt{location_{1, idx_1,}}$\\$\mathtt{location_{2}}$, align=center, ] -> "...1"[as=$\ldots$] -> "locationi" [as=$\mathtt{location_i}$] -> "...2"[as=$\ldots$] -> "locationn"[as={$\mathtt{location_n}$}],
          },
          "location1" ->[gray!90!black] "location11",
          "location1" ->[gray!90!black] "location1k",
          "location1" ->[gray!90!black] "...k",
          "location1" ->[gray!90!black] "...k2"
        };
      \end{tikzpicture}
      \label{eq:location_tree}
    \end{equation}
  \end{figure}

  Die Berechnung der \colorbold{Adresse} für eine beliebige Folge verschiedener Datentypen $(\mathtt{location_{1, idx_1},\enspace\ldots,\enspace location_{n, idx_n}})$, die das Resultat einer Aneinandereihung von \colorbold{Zugriffen} auf \colorbold{Pointerelemente}, \colorbold{Arrayelemente} und \colorbold{Structattributte} unterschiedlicher Datentypen $\mathtt{location_{i}}$ ist (z.B. \smalltt{*complex\_var.attr3[2]}), kann mittels der Formel~\ref{eq:adresse_von_derived_location_allgemein}:
  % https://tex.stackexchange.com/questions/21290/how-to-make-left-right-pairs-of-delimiter-work-over-multiple-lines
  \begin{equation}
  \mathtt{ref(location_{1, idx_1},\enspace\ldots,\enspace location_{n, idx_n})} = \mathtt{ref(location_1)} + \sum_{i=1}^{n-1}\sum_{k=1}^{idx_i - 1} \mathtt{\operatorname{size}(location_{i, k})}
  \label{eq:adresse_von_derived_location_allgemein}
  \end{equation}
  berechnet werden.\footnote{Die \colorbold{äußere Schleife} iteriert nacheinander über die Folge von Datentypen, die aus den \colorbold{Zugriffen} auf \colorbold{Pointerelmente}, \colorbold{Arrayelmente} oder \colorbold{Structattribute} resultiert. Die \colorbold{innere Schleife} iteriert über alle \colorbold{Elemente} oder \colorbold{Attribute} des momentan betrachteten \colorbold{Datentyps} $\mathtt{location_i}$, die vor dem \colorbold{Element} / \colorbold{Attribut} $\mathtt{location_{i, idx_i}}$ liegen.}

  Dabei darf nur der letzte Knoten $\mathtt{location_n}$ den Datentyp \colorbold{Pointer} haben. Ist in einer Folge von  \colorbold{Datentypen} ein Knoten vom Datentyp \colorbold{Pointer}, der nicht der \colorbold{letzte Datentyp} $\mathtt{location_n}$ in der Folge ist, so muss die \colorbold{Adressberechnung} in $2$ Adressberechnungen aufgeteilt werden, wobei die \colorbold{erste Adressberechnung} vom ersten Datentyp $\mathtt{location_1}$ bis direkt zum Dantentyp Pointer geht $\mathtt{location_{pntr}}$ und die \colorbold{zweite Adressberechnung} einen Dantentyp nach dem Datentyp Pointer anfängt $\mathtt{datatpye_{pntr+1}}$ und bis zum letzten Datenyp $\mathtt{location_n}$ geht. Bei der \colorbold{zweiten Adressberechnung} muss dabei die \colorbold{Adresse} $\mathtt{ref(location_1)}$ des Summanden aus der Formel~\ref{eq:adresse_von_derived_location_allgemein} auf den Inhalt der Speicherzelle an der gerade in der \colorbold{zweiten Adressberechnung} berechneten Adresse $\mathtt{M\left[ref{location_1\ldots location_{pntr}}\right]}$ gesetzt werden.

  Die Formel~\ref{eq:adresse_von_derived_location_allgemein} stellt dabei eine \colorbold{Verallgemeinerung} der Formel~\ref{eq:adresse_von_arrayelement} dar, die für alle möglichen Aneinandereihungen von Zugriffen auf \colorbold{Pointerelemente}, \colorbold{Arrayelementen} und \colorbold{Structattribute} funktioniert (z.B. \smalltt{(*complex\_var.attr2)[3]}). Da die Formel \colorbold{allgemein} sein muss, lässt sie sich nicht so elegant mit einem Produkt $\prod$ schreiben, wie die Formel~\ref{eq:adresse_von_arrayelement}, da man nicht davon ausgehen kann, dass alle Elemente den gleichen Datentyp haben\footnote{Structattribute haben \colorbold{unterschiedliche} Größen.}.

  Die Komposition \smalltt{Ref(Global(num))} bzw. \smalltt{Ref(Stackframe(num))} repräsentiert dabei den Summanden $\mathtt{ref(location_1)}$ in der Formel.

  Die Komposition \smalltt{Exp(Attr(Stack(Num('1')), name))} repräsentiert dabei einen Summanden $\sum_{k=1}^{idx_i - 1} \mathtt{\operatorname{size}(location_{i, k})}$ in der Formel.

Die Komposition \smalltt{Exp(Stack(Num('1')))} repräsentiert dabei das Lesen des \colorbold{Inhalts} $\mathtt{M\left[ref(location_{1, idx_1},\enspace\ldots,\enspace location_{n, idx_n})\right]}$ der Speicherzelle an der finalen \colorbold{Adresse} $\mathtt{ref(location_{1, idx_1},\enspace\ldots,\enspace location_{n, idx_n})}$.
\end{Special_Paragraph}

\begin{Definition}{Location}{location}
  Kollektiver Begriff für \colorbold{Variablen}, \colorbold{Attribute} bzw. \colorbold{Elemente} von Variablen bestimmter Datentypen, \colorbold{Speicherbereiche auf dem Stack}, die \colorbold{temporäre Zwischenergebnisse} speichern und \colorbold{Register}.

  Im Grunde genommen alles, was mit einem \colorbold{Programm zu tuen} hat und irgendwo \colorbold{gespeichert} ist.\footcite{g_siek_course_2022}
\end{Definition}

\begin{Definition}{Entarteter Baum}{entarteter_baum}
  Baum bei dem jeder Knoten \colorbold{maximal} eine ausgehende Kante hat, also maximal \colorbold{Außengrad} $1$.

  \textnormal{Oder alternativ:} Baum beim dem jeder Knoten des Baumes \colorbold{maximal} eine eingehende Kante hat, also maximal \colorbold{Innengrad} $1$.

  Der Baum entspricht also einer \colorbold{verketteten Liste}.\footcite{noauthor_baume_nodate}
\end{Definition}


\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-14}}]{./code_examples/example_struct_attr_access.picoc_mon}
  \caption{PicoC-Mon Pass für Zugriff auf Structattribut}
  \label{code:picoc_mon_pass_für_zugriff_auf_structattribut}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_zugriff_auf_structattribut} werden die \colorbold{Kompositionen} \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} und \smalltt{Exp(Stack(Num('1')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-27,29-31,33-35}}]{./code_examples/example_struct_attr_access.reti_blocks}
  \caption{RETI-Blocks Pass für Zugriff auf Structattribut}
  \label{code:reti_blocks_pass_für_zugriff_auf_structattribut}
\end{code}

\subsubsection{Zuweisung an Structattribut}
Die \colorbold{Zuweisung an ein Structattribut} (z.B. \smalltt{st.y = 42}) wird im Folgenden anhand des Beispiels in Code~\ref{code:picoc_code_für_zuweisung_an_structattribut} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={5}}]{./code_examples/example_struct_attr_assignment.picoc}
  \caption{PicoC-Code für Zuweisung an Structattribut}
  \label{code:picoc_code_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{Abstact Syntax Tree} wird eine  \colorbold{Zuweisung an ein Structattribut} (z.B. \smalltt{st.y = 42}) durch die Komposition \smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_struct_attr_assignment.ast}
  \caption{Abstract Syntax Tree für Zuweisung an Structattribut}
  \label{code:abstract_syntax_tree_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_zuweisung_an_structattribut} wird die Komposition \smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))} auf ähnliche Weise ausgewertet, wie die Komposition, die einen \colorbold{Zugriff auf ein Arrayelement} \smalltt{ Assign(Subscr(Name('ar'), Num('2')), Num('42'))} in Subkapitel~\ref{sec:zuweisung_an_arrayindex} darstellt. Daher wird hier, um Wiederholung zu vermeiden nur auf wichtige Aspekte hingewiesen und ansonsnten auf das Unterkapitel~\ref{sec:zuweisung_an_arrayindex} verwiesen.

Im Gegensatz zum Vorgehen in Unterkapitel~\ref{sec:zuweisung_an_arrayindex} muss hier für das Auswerten des \colorbold{linken} Container-Knoten \smalltt{Attr(Name('st'), Name('y'))} von \smalltt{\smalltt{Assign(Attr(Name('st'), Name('y')), Num('42'))}} wie in Subkapitel~\ref{sec:zugriff_auf_structattribut} vorgegangen werden.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={12-15}}]{./code_examples/example_struct_attr_assignment.picoc_mon}
  \caption{PicoC-Mon Pass für Zuweisung an Structattribut}
  \label{code:picoc_mon_pass_für_zuweisung_an_structattribut}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_zuweisung_an_structattribut} werden die \colorbold{Kompositionen} \smalltt{Exp(Num('42'))}, \smalltt{Ref(Global(Num('0')))}, \smalltt{Ref(Attr(Stack(Num('1')), Name('y')))} und \smalltt{Assign(Stack(Num('1')), Stack(Num('2')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={24-26,28-31,33-35,37-40}}]{./code_examples/example_struct_attr_assignment.reti_blocks}
  \caption{RETI-Blocks Pass für Zuweisung an Structattribut}
  \label{code:reti_blocks_pass_für_zuweisung_an_structattribut}
\end{code}

\subsection{Umsetzung des Zugriffs auf Derived locations im Allgemeinen}
\subsubsection{Übersicht}
\label{sec:übersicht}
\begin{figure}
  \centering
  \begin{File}[remember as=input]
    Start
  \end{File}
  \vspace{0.6cm}
  \begin{Code_Frame}[remember as=anfangsteil]{Anfangsteil}
    \codebox[title=Variable vom Stackframe, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=A]{./code_examples/ubersicht_anfangsteil_global.special}
    \hfill
    \codebox[title=Variable aus Globalen Statischen Daten, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=A]{./code_examples/ubersicht_anfangsteil_stackframe.special}
  \end{Code_Frame}
  \vspace{0.6cm}
  \begin{Code_Frame}[remember as=mittelteil]{Mittelteil}
    \codebox[title=Arrayindexzugriff auf Array, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_array.special}
    \hfill
    \codebox[title=Arrayindexzugriff auf Pointer, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_pntr.special}
    \hfill
    \codebox[title=Structattributzugriff auf Struct, width=0.32\linewidth, nobeforeafter, minted language=text, equal height group=M]{./code_examples/ubersicht_mittelteil_struct.special}
  \end{Code_Frame}
  \vspace{0.8cm}
  \begin{Code_Frame}[remember as=schlussteil]{Schlussteil}
    \codebox[title={Letzer Datentyp ist Struct, Pointer oder Primitiver Datentyp}, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=S]{./code_examples/ubersicht_schlussteil_struct_int_char.special}
    \hfill
    \codebox[title=Letzer Datentyp ist Array, width=0.4\linewidth, nobeforeafter, minted language=text, equal height group=S]{./code_examples/ubersicht_schlussteil_array_pntr.special}
  \end{Code_Frame}
  \vspace{0.8cm}
  \begin{File}[remember as=output, hbox]
    Ende
  \end{File}
  \begin{tikzpicture}[overlay,remember picture,line width=1mm,draw=PrimaryColor]
  \draw[->] (input.south) to node[right, align=center] {\colorbold{nichts} momentan \colorbold{relevantes} auf dem Stack} (anfangsteil.north);
  \draw[->] (anfangsteil.south) to node[right, align=center] {\colorbold{Startadresse} der Variable auf dem Stack} (mittelteil.north);
  \draw [->] (mittelteil.east)arc(-160:160:0.8) node[right, align=center] {siehe \footnotemark};
  \draw[->] (mittelteil.south) to node[right, align=center] {\colorbold{Startadresse} / \colorbold{Adresse} eines \colorbold{Pointerelements},\\ \colorbold{Arrayelements} oder \colorbold{Structattributes} auf dem Stack} (schlussteil.north);
  \draw[->] (schlussteil.south) to node[right, align=center] {\colorbold{Inhalt} der Speicherzelle an der berechneten\\ \colorbold{Adresse} oder berechnete \colorbold{Adresse} selbst} (output.north);
  \end{tikzpicture}
  \caption{Allgemeine Veranschaulichung des Zugriffs auf Derived Datatypes}
  \label{fig:zugriff_auf_derived_datatypes_veranschaulicht}
\end{figure}

In den Unterkapiteln \ref{sec:umsetzung_von_pointern}, \ref{sec:umsetzung_von_arrays} und \ref{sec:umsetzung_von_structs} fällt auf, dass der \colorbold{Zugriff} auf \colorbold{Elemente} / \colorbold{Attribute} der in diesen Kapiteln beschriebenen Datentypen (\colorbold{Pointer}, \colorbold{Array} und \colorbold{Struct}) sehr ähnlich abläuft. Es lässt sich ein allgemeines Vorgehen, bestehend aus einem \colorbold{Anfangsteil}, \colorbold{Mittelteil} und \colorbold{Schlussteil} darin erkennen.

Dieses Vorgehen ist in Abbildung~\ref{fig:zugriff_auf_derived_datatypes_veranschaulicht} veranschaulicht. Dieses Vorgehen erlaubt es auch gemischte Ausdrücke zu schreiben, in denen die verschiedenen \colorbold{Zugriffsarten} für \colorbold{Elemente} / \colorbold{Attribute} der Datenypen \colorbold{Pointer}, \colorbold{Array} und \colorbold{Struct} gemischt sind (z.B. \smalltt{(*st\_var.ar)[0]}).

Dies ist möglich, indem im \colorbold{Mittelteil}, je nachdem, ob das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} des \smalltt{Ref(exp, \textcolor{gray!90!black}{datatype})}-Container-Knotens ein \smalltt{ArrayDecl(nums, datatype)}, ein \smalltt{PntrDecl(num, datatype)} oder \smalltt{StructSpec(name)} beinhaltet und die dazu passende \colorbold{Zugriffsoperation} \smalltt{Subscr(exp1, exp2)} oder \smalltt{Attr(exp, name)} vorliegt, einen anderen \colorbold{RETI-Code} generiert wird. Dieser \colorbold{RETI-Code} berechet die \colorbold{Startadresse} eines gewünschten \colorbold{Pointerelmements}, \colorbold{Arrayelements} oder \colorbold{Structattributs}.

Würde man bei einem \smalltt{Subscr(Name('var'), exp2)} den Datentyp der Variable \smalltt{Name('var')} von \smalltt{ArrayDecl(nums, IntType())} zu \smalltt{PointerDecl(num, IntType())} ändern, müsste nur der \colorbold{Mittelteil} ausgetauscht werden. \colorbold{Anfangsteil} und \colorbold{Schlussteil} bleiben unverändert.

Die \colorbold{Zugriffsoperation} muss dabei zum \colorbold{Datentyp} im \textcolor{gray!90!black}{versteckten Attribut} \smalltt{datatype} passen, ansonsten gibt es eine \smalltt{DatatypeMismatch}-\colorbold{Fehlermeldung}. Ein \colorbold{Zugriff auf ein Arrayindex} \smalltt{Subscr(exp1, epp2)} kann dabei mit den Datentypen \colorbold{Array} \smalltt{ArrayDecl(nums, datatype)} und \colorbold{Pointer} \smalltt{PntrDecl(num, datatype)} kombiniert werden. Allerdings benötigen beide Kombinationen unterschiedlichen \colorbold{RETI-Code}. Das liegt daran, dass bei einem \colorbold{Pointer} \smalltt{PntrDecl(num, datatype)} die \colorbold{Adresse}, die auf dem  \colorbold{Stack} liegt auf eine Speicherzelle mit einer weiteren \colorbold{Adresse} zeigt und das gewünschte Element erst zu finden ist, wenn man der letzteren \colorbold{Adresse} folgt. Ein \colorbold{Zugriff auf ein Structattribut} \smalltt{Attr(exp, name)} kann nur mit dem Datentyp \colorbold{Struct} \smalltt{StructSpec(name)} kombiniert werden.

\begin{Special_Paragraph}
Um Verwirrung vorzubeugen, wird hier vorausschauend nochmal darauf hingewiesen, dass eine \colorbold{Dereferenzierung} in der Form \smalltt{Deref(exp1, exp2)} nicht mehr existiert, denn wie in Unterkapitel~\ref{sec:umsetzung_von_pointern} bereits erklärt wurde, wurde der \colorbold{Container-Knoten} \smalltt{Deref(exp1, exp2)} im \colorbold{PicoC-Shrink Pass} durch \smalltt{Subscr(exp1, exp2)} ersetzt. Das hatte den Zweck, \colorbold{doppelten Code} zu vermeiden, da die \colorbold{Dereferenzierung} und der \colorbold{Zugriff auf ein Arrayelement} jeweils gegenseitig austauschbar sind. Der \colorbold{Zugriff auf einen Arrayindex} steht also gleichermaßen auch für eine \colorbold{Dereferenzierung}.
\end{Special_Paragraph}

Das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} beinhaltet den \colorbold{Unterdatentyp}, in welchem der Zugriff auf ein \colorbold{Pointerelment}, \colorbold{Arrayelement} oder \colorbold{Structattribut} erfolgt. Der \colorbold{Unterdatentyp} ist dabei ein \colorbold{Teilbaum} des Baumes, der vom gesamten \colorbold{Datentyp} der \colorbold{Variable} gebildet wird. Wobei man sich allerdings nur für den obersten \colorbold{Container-Knoten} oder \colorbold{Token-Knoten} in diesem \colorbold{Unterdatentyp} interessiert und die möglicherweise unter diesem momentan betrachteten \colorbold{Knoten} liegenden \colorbold{Container-Knoten} und \colorbold{Token-Knoten} in einem anderen \smalltt{Ref(exp, \textcolor{gray!90!black}{versteckte Attribut})}-Container-Knoten dem \textcolor{gray!90!black}{versteckte Attribut} zugeordnet sind. Das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} enthält also die Information auf welchen \colorbold{Unterdatentyp} im dem momentanen \colorbold{Kontext} gerade zugegriffen wird.

Der \colorbold{Anfangsteil}, der durch die Komposition \smalltt{Ref(Name('var'))} repräsentiert wird, ist dafür zuständig die \colorbold{Startadresse} der Variablen \smalltt{Name('var')} auf den Stack zu schreiben und je nachdem, ob diese Variable in den \colorbold{Globalen Statischen Daten} oder auf dem \colorbold{Stackframe} liegt einen anderen \colorbold{RETI-Code} zu generieren.

Der \colorbold{Schlussteil} wird durch die Komposition \smalltt{Exp(Stack(Num('1')), \textcolor{gray!90!black}{datatype})} dargestellt. Je nachdem, ob  das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} ein \smalltt{CharType()}, \smalltt{IntType()}, \smalltt{PntrDecl(num, datatype)} oder \smalltt{StructType(name)} ist, wird ein entsprechender \colorbold{RETI-Code} generiert, der die \colorbold{Adresse}, die auf dem \colorbold{Stack} liegt dazu nutzt, um den \colorbold{Inhalt} der Speicherzelle an dieser \colorbold{Adresse} auf den \colorbold{Stack} zu schreiben. Dabei wird die Speicherzelle der \colorbold{Adresse} mit dem \colorbold{Inhalt} auf den sie selbst zeigt überschreiben. Bei einem \smalltt{ArrayDecl(nums, datatype)} hingegen wird kein weiterer \colorbold{RETI-Code} generiert, die \colorbold{Adresse}, die auf dem \colorbold{Stack} liegt, stellt bereits das gewünschte Ergebnis dar.

\colorbold{Arrays} haben in der Sprache $L_C$ und somit auch in $L_{PiocC}$ die Eigenheit, dass wenn auf ein gesamtes \colorbold{Array} zugegriffen wird\footnote{Und nicht auf ein \colorbold{Element} des Arrays.}, die \colorbold{Adresse} des ersten Elements ausgegeben wird und nicht der \colorbold{Inhalt} der Speicherzelle des ersten Elements. Bei allen anderen in der Sprache $L_{PicoC}$ implementieren Datentypen wird immer der \colorbold{Inhalt} der Speicherzelle ausgegeben, die an der \colorbold{Adresse} zu finden ist, die auf dem \colorbold{Stack} liegt.

% https://tex.stackexchange.com/questions/107603/create-a-footnote-in-node-in-a-tikzpicture
\footnotetext{\colorbold{Startadresse} / \colorbold{Adresse} eines \colorbold{Pointerelements}, \colorbold{Arrayelements} oder \colorbold{Structattributes} auf dem Stack.}

\begin{Special_Paragraph}
\colorbold{Implementieren} lässt sich dieses Vorgehen, indem beim Antreffen eines \smalltt{Subscr(exp1, exp2)} oder \smalltt{Attr(exp, name)} Ausdrucks ein \smalltt{Exp(Stack(Num('1')))} an die Spitze einer \colorbold{Liste der generierten Ausdrücke} gesetzt wird und der Ausdruck selbst als \smalltt{exp}-Attribut des \smalltt{Ref(exp)}-Knotens gesetzt wird und hinter dem \smalltt{Exp(Stack(Num('1')))}-Container-Knoten in der Liste eingefügt wird. Beim Antreffen eines \smalltt{Ref(exp)} wird fast gleich vorgegangen, wie beim Antreffen eines \smalltt{Subscr(exp1, exp2)} oder \smalltt{Attr(exp, name)}, nur, dass kein \smalltt{Exp(Stack(Num('1')))} vorne an die Spitze der \colorbold{Liste der generierten Ausdrücke} gesetzt wird. Und ein \smalltt{Ref(exp)} bei dem \smalltt{exp} direkt ein  \smalltt{Name(str)} ist, wird dieser einfach direkt durch \smalltt{Ref(Global(num))} bzw. \smalltt{Ref(Stackframe(num))} ersetzt.

Es wird solange dem jeweiligen \smalltt{exp1} des \smalltt{Subscr(exp1, exp2)}-Knoten, dem \smalltt{exp} des \smalltt{Attr(exp, name)}-Knoten oder dem \smalltt{exp} des \smalltt{Ref(exp)}-Knoten gefolgt und der jeweilige \colorbold{Container-Knoten} selbst als \smalltt{exp} des \smalltt{Ref(exp)}-Knoten eingesetzt und hinten in die \colorbold{Liste der generierten Ausdrücke} eingefügt, bis man bei einem \smalltt{Name(name)} ankommt. Der \smalltt{Name(name)}-Knoten wird zu einem \smalltt{Ref(Global(num))} oder \smalltt{Ref(Stackframe(num))} umgewandelt und ebenfalls ganz hinten in die \colorbold{Liste der generierten Ausdrücke} eingefügt.
Wenn man dem \smalltt{exp} Attribut eines \smalltt{Ref(exp)}-Knoten folgt, wird allerdings kein \smalltt{Ref(exp)} in die \colorbold{Liste der generierten Ausdrücke} eingefügt, sondern das \smalltt{datatype}-Attribut des zuletzt eingefügten \smalltt{Ref(exp, \textcolor{gray!90!black}{datatype})}  manipuliert, sodass dessen \smalltt{datatype} in ein \smalltt{ArrayDecl([Num('1')], datatype)} eingebettet ist und so ein auf das  \smalltt{Ref(exp)} folgendes \smalltt{Deref(exp1, exp2)} oder \smalltt{Subscr(exp1, exp2)} direkt behandelt wird.

Parallel wird eine Liste der \smalltt{Ref(exp)}-Knoten geführt, deren \textcolor{gray!90!black}{versteckte Attribute} \smalltt{datatype} und \smalltt{error\_data} die entsprechenden Informationen zugewiesen bekommen müssen. Sobald man beim \smalltt{Name(name)}-Knoten angekommen ist und mithilfe dieses in der \colorbold{Symboltabelle} den \colorbold{Dantentyp} der Variable nachsehen kann, wird der \colorbold{Datentyp} der Variable nun ebenfalls, wie die Ausdrücke \smalltt{Subscr(exp1, exp2)} und \smalltt{Attr(exp, name)} schrittweise durchiteriert und dem jeweils nächsten \smalltt{datatype}-Attribut gefolgt werden. Das \colorbold{Iterieren} über den \colorbold{Datentyp} wird solange durchgeführt, bis alle \smalltt{Ref(exp)}-Knoten ihren im jeweiligen \colorbold{Kontext} vorliegenden \colorbold{Datentyp} in ihrem \smalltt{datatype}-Attribut zugewiesen bekommen haben. Alles andere führt zu einer \colorbold{Fehlermeldung}, für die das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{error\_data} genutzt wird.\footnote{Man kann diese Implementierung gut mit dem \colorbold{Auseinanderrollen} und \colorbold{Wieder-Einrollen} einer \colorbold{Spirale} vergleichen.}
\end{Special_Paragraph}

Im Folgenden werden anhand mehrerer Beispiele die einzelnen Abschnitte \colorbold{Anfangsteil}~\ref{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}, \colorbold{Mittelteil}~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} und \colorbold{Schlussteil}~\ref{sec:schlussteil_für_die_verschiedenen_derived_datatypes} bei der Kompilierung von \colorbold{Zugriffen} auf \colorbold{Pointerelemente}, \colorbold{Arrayelemente}, \colorbold{Structattribute} bei gemischten Ausdrücken, wie \smalltt{(*st\_first.ar)[0];} einzeln isoliert betrachtet und erläutert.

\subsubsection{Anfangsteil}
\label{sec:einleitungsteil_für_globale_statische_daten_und_stackframe}
Der \colorbold{Anfangsteil}, bei dem die \colorbold{Adresse} einer Variable auf den \colorbold{Stack} geschrieben wird (z.B. \smalltt{\&st}), wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_einleitungsteil} erklärt.

% Stack und Globale Statische Daten, unterschieldihe Berechnung der Adressen
% unterschiedliche Adressberechnung
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={6, 12}}]{./code_examples/example_derived_dts_introduction_part.picoc}
  \caption{PicoC-Code für den Anfangsteil}
  \label{code:picoc_code_einleitungsteil}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_einleitungsteil} wird die \colorbold{Refererenzierung} \smalltt{\&complex\_var} mit der Komposition \smalltt{Exp(Ref(Name('complex\_var')))} dargestellt. Üblicherweise wird aber einfach nur \smalltt{Ref(Name('complex\_var')} geschrieben, aber da beim Erstellen des \colorbold{Abstract Syntx Tree} jeder \colorbold{Logischer Ausdruck} in ein \smalltt{Exp(exp)} eingebettet wird, ist das \smalltt{Ref(Name('complex\_var')} in ein \smalltt{Exp()} eingebettet. Man müsste an vielen Stellen eine gesonderte \colorbold{Fallunterschiedung} aufstellen, um von \smalltt{Exp(Ref(Name('complex\_var')))} das \smalltt{Exp()} zu entfernen, obwohl das \smalltt{Exp()} in den darauffolgenden \colorbold{Passes} so oder so herausgefiltet wird. Daher wurde darauf verzichtet den Code ohne triftigen Grund \colorbold{komplexer} zu machen.
% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={17, 26}}]{./code_examples/example_derived_dts_introduction_part.ast}
  \caption{Abstract Syntax Tree für den Anfangsteil}
  \label{code:abstract_syntax_tree_einleitungsteil}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_einleitungsteil} wird die Komposition \smalltt{Exp(Ref(Name('complex\_var')))} durch die Komposition \smalltt{Ref(Global(Num('9')))} bzw. \smalltt{Ref(Stackframe(Num('9')))} ersetzt, je nachdem, ob die Variable \smalltt{Name('complex\_var')} in den \colorbold{Globalen Statischen Daten} oder auf dem \colorbold{Stack} liegt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={10,19}}]{./code_examples/example_derived_dts_introduction_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Anfangsteil}
  \label{code:picoc_mon_pass_einleitungsteil}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_einleitungsteil} werden die Komposition \smalltt{Ref(Global(Num('9')))} bzw. \smalltt{Ref(Stackframe(Num('9')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={11-14,25-28}}]{./code_examples/example_derived_dts_introduction_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Anfangsteil}
  \label{code:reti_blocks_pass_einleitungsteil}
\end{code}

\subsubsection{Mittelteil}
\label{sec:mittelteil_für_die_verschiedenen_derived_datatypes}

Der \colorbold{Mittelteil}, bei dem die \colorbold{Startadresse} / \colorbold{Adresse} einer Aneinandereihung von Zugriffen auf \colorbold{Pointerelemente}, \colorbold{Arrayelemente} oder \colorbold{Structattribute} berechnet wird (z.B. \smalltt{(*complex\_var.ar)[2-2]}), wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_mittelteil} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={6}}]{./code_examples/example_derived_dts_main_part.picoc}
  \caption{PicoC-Code für den Mittelteil}
  \label{code:picoc_code_mittelteil}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_mittelteil} wird die Aneinandererihung von Zugriffen auf \colorbold{Pointerelemente}, \colorbold{Arrayelemente} und \colorbold{Structattribute} \smalltt{(*complex\_var.ar)[2-2]} durch die Komposition \smalltt{Exp(Subscr(Deref(Attr(Name('complex\_var'), Name('ar')), Num('0')), BinOp(Num('2'), Sub('-'), Num('2'))))} dargestellt.
% spezielles Vorgehen bei PntrDecl

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16}}]{./code_examples/example_derived_dts_main_part.ast}
  \caption{Abstract Syntax Tree für den Mittelteil}
  \label{code:abstract_syntax_tree_mittelteil}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_mittelteil} wird die Komposition \smalltt{Exp(Subscr(Deref(Attr(Name('complex\_var'), Name('ar')), Num('0')), BinOp(Num('2'), Sub('-'), Num('2'))))} durch die Kompositionen \smalltt{Ref(Attr(Stack(Num('1')), Name('ar')))}, \smalltt{Exp(Num('2'))}, \smalltt{Exp(BinOp(Stack(Num('2')), Sub('-'), Stack(Num('1'))))}, \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} und \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} ersetzt. Bei \smalltt{Subscr(exp1, exp2)} wird dieser Container-Knoten einfach dem \smalltt{exp} Attribut des \smalltt{Ref(exp)}-Container Knoten zugewiesen und die \colorbold{Indexberechnung} für \smalltt{exp2} davorgezogen (in diesem Fall dargestellt durch \smalltt{Exp(Num('2'))} und \smalltt{Exp(BinOp(Stack(Num('2')), Sub('-'), Stack(Num('1'))))}) und über \smalltt{Stack(Num('1'))} auf das Ergebnis der \colorbold{Indexberechnung} auf dem \colorbold{Stack} zugegriffen: \smalltt{Exp(BinOp(Stack(Num('2')), Sub('-'), Stack(Num('1'))))}.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-21}}]{./code_examples/example_derived_dts_main_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Mittelteil}
  \label{code:picoc_mon_pass_mittelteil}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_mittelteil} werden die Kompositionen \smalltt{Ref(Attr(Stack(Num('1')), Name('ar')))}, \smalltt{Exp(Num('2'))}, \smalltt{Exp(BinOp(Stack(Num('2')), Sub('-'), Stack(Num('1'))))}, \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} und \smalltt{Ref(Subscr(Stack(Num('2')), Stack(Num('1'))))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt. Bei der Generierung des \colorbold{RETI-Code} muss auch das \textcolor{gray!90!black}{versteckte Attribut} \smalltt{datatype} im \smalltt{Ref(exp, \textcolor{gray!90!black}{datatpye})}-Container-Knoten berücksichtigt werden, was in Unterkapitel~\ref{sec:übersicht} zusammen mit der Abbildung~\ref{fig:zugriff_auf_derived_datatypes_veranschaulicht} bereits erklärt wurde.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={33-35,37-39,41-47,49-51,53-55,57-61,63-68}}]{./code_examples/example_derived_dts_main_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Mittelteil}
  \label{code:reti_blocks_pass_mittelteil}
\end{code}
% spezielles Vorgehen bei PntrDecl

\subsubsection{Schlussteil}
\label{sec:schlussteil_für_die_verschiedenen_derived_datatypes}

Der \colorbold{Schlussteil}, bei dem der \colorbold{Inhalt} der Speicherzelle an der \colorbold{Adresse}, die im \colorbold{Anfangsteil}~\ref{sec:einleitungsteil_für_globale_statische_daten_und_stackframe} und \colorbold{Mittelteil}~\ref{sec:mittelteil_für_die_verschiedenen_derived_datatypes} auf dem \colorbold{Stack} berechnet wurde, auf den \colorbold{Stack} gespeichert wird\footnote{Und dabei die Speicherzelle der \colorbold{Adresse} selbst überschreibt.}, wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_schlussteil} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={10-12}}]{./code_examples/example_derived_dts_final_part.picoc}
  \caption{PicoC-Code für den Schlussteil}
  \label{code:picoc_code_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={19-21}}]{./code_examples/example_derived_dts_final_part.ast}
  \caption{Abstract Syntax Tree für den Schlussteil}
  \label{code:abstract_syntax_tree_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={22,27,32}}]{./code_examples/example_derived_dts_final_part.picoc_mon}
  \caption{PicoC-Mon Pass für den Schlussteil}
  \label{code:picoc_mon_pass_schlussteil}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={55,74-76,96-98}}]{./code_examples/example_derived_dts_final_part.reti_blocks}
  \caption{RETI-Blocks Pass für den Schlussteil}
  \label{code:reti_blocks_pass_schlussteil}
\end{code}

% Umgang, wenn Datentyp abrubt aufhört am Ende
