%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1_Tables_DT_AST.tex,
% ./Implementierung2_Pntr_Array.tex,
% ./Implementierung3_Struct_Derived.tex,
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Funktionen}
\subsubsection{Mehrere Funktionen}

Die Umsetzung \colorbold{mehrerer Funktionen} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_3_funktionen} erklärt. Dieses Beispiel soll nur zeigen, wie Funktionen in verschiedenen, für die Kompilierung von Funktionen relevanten \colorbold{Passes} kompiliert werden. Das Beispiel ist so gewählt, dass es möglichst \colorbold{isoliert} von weiterem möglicherweise störendem Code ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_3_funs.picoc}
  \caption{PicoC-Code für 3 Funktionen}
  \label{code:picoc_code_für_3_funktionen}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_3_Funktionen} wird eine \colorbold{Funktion}, wie z.B. \smalltt{void fun(int param;)\{\enspace return param;\enspace \}} mit der Komposition \smalltt{FunDef(IntType(), Name('fun'), [Alloc(Writeable(), IntType(), Name('fun'))], [Return(Exp(Name('param')))])} dargestellt. Die einzelnen \colorbold{Attribute} dieses Container-Knoten sind in Tabelle~\ref{tab:picoc_knoten_teil_4} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.ast}
  \caption{Abstract Syntax Tree für 3 Funktionen}
  \label{code:abstract_syntax_tree_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-Blocks Pass} in Code~\ref{code:picoc_blocks_pass_für_3_Funktionen} werden die \colorbold{Statements} der Funktion in \colorbold{Blöcke} \smalltt{Block(name, stmts\_instrs)} aufgeteilt. Dabei bekommt ein Block \smalltt{Block(name, stmts\_instrs)}, der die Statements der Funktion vom \colorbold{Anfang} bis zum \colorbold{Ende} oder bis zum Auftauchen eines \smalltt{If(exp, stmts)}, \smalltt{IfElse(exp, stmts1, stmts2)}, \smalltt{While(exp, stmts)} oder \smalltt{DoWhile(exp, stmts)}\footnote{Eine Erklärung dazu ist in Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} zu finden.} beinhaltet den \colorbold{Bezeichner} bzw. den \smalltt{Name(str)}-Token-Knoten der Funktion an sein \colorbold{Label} bzw. an sein \smalltt{name}-Attribut zugewiesen. Dem \colorbold{Bezeichner} wird vor der Zuweisung allerdings noch eine \colorbold{Nummer} angehängt \smalltt{<name>.<nummer>}\footnote{Der \colorbold{Grund} dafür kann im Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} nachgelesen werden.}.

Es werden parallel dazu neue Zuordnungen im \colorbold{Dictionary} \smalltt{fun\_name\_to\_block\_name} hinzugefügt. Das \colorbold{Dicionary} ordnet einem \colorbold{Funktionsnamen} den \colorbold{Blocknamen} des Blockes, der das erste \colorbold{Statement} der Funktion enthält und dessen \colorbold{Bezeichner} \smalltt{<name>.<nummer>} bis auf die angehängte \colorbold{Nummer} identisch zu dem der Funktion ist zu\footnote{Das ist der \colorbold{Block}, über den im \colorbold{obigen letzten Paragraph} gesprochen wurde.}. Diese Zuordnung ist nötig, da \colorbold{Blöcke} noch eine \colorbold{Nummer} an ihren Bezeichner \smalltt{<name>.<nummer>} angehängt haben.

% Dieser Pass hat allerdings keine direkte wichtige Bedeutung bei der Kompilierung von \colorbold{Funktionen}. Die Erwähnung dieses \colorbold{Pass} ist nur wichtig, weil nach diesem Pass die \colorbold{Statements} in \colorbold{Blöcke} aufgeteilt sind.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_blocks}
  \caption{PicoC-Blocks Pass für 3 Funktionen}
  \label{code:picoc_blocks_pass_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_3_Funktionen} werden die \smalltt{FunDef(datatype, name, allocs, stmts)}-Container-Knoten komplett aufgelöst, sodass sich im \smalltt{File(name, decls\_defs\_blocks)}-Container-Knoten nur noch Blöcke befinden.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_mon}
  \caption{PicoC-Mon Pass für 3 Funktionen}
  \label{code:picoc_mon_pass_für_3_Funktionen}
\end{code}

Nach dem \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_3_Funktionen} gibt es nur noch \colorbold{RETI-Instructions}, die Blöcke wurden entfernt und die \colorbold{RETI-Instructions} in diesen Blöcken wurden genauso zusammengefügt, wie die Blöcke angeordnet waren. Ohne die \colorbold{Kommentare} könnte man die Funktionen nicht mehr direkt ausmachen, denn die \colorbold{Kommentare} enthalten die \colorbold{Labelbezeichner} \smalltt{<name>.<nummer>} der Blöcke, die in diesem Beispiel immer zugleich bis auf die Nummer, dem \colorbold{Namen} der jeweiligen \colorbold{Funktion} entsprechen.

Da es in der \smalltt{main}-Funktion keinen \colorbold{Funktionsaufruf} gab, wird der Code, der nach der \colorbold{Instruction} in der \colorbold{markierten Zeile} kommt nicht mehr betreten. Funktionen sind im \colorbold{RETI-Code} nur dadurch existent, dass im RETI-Code \colorbold{Sprünge} (z.B. \smalltt{JUMP<rel> <im>}) zu den jeweils richtigen Positionen gemacht werden, nämlich dorthin, wo die \colorbold{RETI-Instructions}, die aus den \colorbold{Statemtens} einer \colorbold{Funktion} kompiliert wurden anfangen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={6}}]{./code_examples/verbose_3_funs.reti}
  \caption{RETI-Blocks Pass für 3 Funktionen}
  \label{code:reti_pass_für_3_Funktionen}
\end{code}

% einfügen unsichtbarer Returns bei void
\newlineparagraph{Sprung zur Main Funktion}

Im vorherigen Beispiel in Code~\ref{code:picoc_code_für_3_funktionen} war die \smalltt{main}-Funktion die \colorbold{erste} Funktion, die im Code vorkam. Dadurch konnte die \smalltt{main}-Funktion direkt betreten werden, da die \colorbold{Ausführung} des Programmes immer ganz vorne im \colorbold{RETI-Code} beginnt. Man musste sich daher keine Gedanken darum machen, wie man die \colorbold{Ausführung}, die von der \smalltt{main}-Funktion ausgeht überhaupt startet.

Im Beispiel in Code~\ref{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} ist die \smalltt{main}-Funktion allerdings \colorbold{nicht} die \colorbold{erste} Funktion. Daher muss dafür gesorgt werden, dass die \smalltt{main}-Funktion die erste Funktion ist, die ausgeführt wird.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8-10}}]{./code_examples/verbose_3_funs_main.picoc}
  \caption{PicoC-Code für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} sind die \colorbold{Funktionen} nur noch durch \colorbold{Blöcke} umgesetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={23-28}}]{./code_examples/verbose_3_funs_main.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\colorbold{Eine simple Möglichkeit} ist es, die \smalltt{main-Funktion} einfach nach \colorbold{vorne} zu schieben, damit diese als \colorbold{erstes} ausgeführt wird. Im \smalltt{File(name, decls\_defs)}-Container-Knoten muss dazu im \smalltt{decls\_defs}-Attribut, welches eine \colorbold{Liste von Funktionen} ist, die \smalltt{main}-Funktion an Index $0$ geschoben werden.

\colorbold{Eine andere Möglichkeit} und die Möglichkeit für die sich in der \colorbold{Implementierung} des \colorbold{PicoC-Compilers} entschieden wurde, ist es, wenn die \smalltt{main}-Funktion nicht die erste auftauchende Funktion ist, einen \smalltt{start.<nummer>}-Block als ersten Block einzufügen, der einen \smalltt{GoTo(Name('main.<nummer>'))}-Container-Knoten enthält, der im \colorbold{RETI Pass}~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} in einen Sprung zur \smalltt{main}-Funktion übersetzt wird.

In der Implementierung des \colorbold{PicoC-Compilers} wurde sich für diese Möglichkeit entschieden, da es für \colorbold{Studenten}, welche die Verwender des \colorbold{PiocC-Compilers} sein werden vermutlich am \colorbold{intuitivsten} ist,  wenn der \colorbold{RETI-Code} für die Funktionen an denselben Stellen relativ zueinander verortet ist, wie die Funktionsdefinitionen im \colorbold{PicoC-Code}.

Das \colorbold{Einsetzen} des \smalltt{start.<nummer>}-Blockes erfolgt im \colorbold{RETI-Patch Pass} in Code~\ref{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}, da der \colorbold{RETI-Patch}-Pass der Pass ist, der für das \colorbold{Ausbessern} (engl. to patch) zuständig ist, wenn z.B. in manchen Fällen die \smalltt{main}-Funktion nicht die erste Funktion ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,29-34}}]{./code_examples/verbose_3_funs_main.reti_patch}
  \caption{RETI-Patch Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} wird das \smalltt{GoTo(Name('main.<nummer>'))} durch den entsprechenden \smalltt{Sprung} \smalltt{JUMP <distanz\_zur\_main\_funktion>} ersetzt und die Blöcke entfernt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={3,19}}]{./code_examples/verbose_3_funs_main.reti}
  \caption{RETI Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\subsubsection{Funktionsdeklaration und -definition und Umsetzung von Scopes}

In der Programmiersprache $L_C$ und somit auch $L_{PicoC}$ ist es notwendig, dass eine Funktion \colorbold{deklariert} ist, bevor man einen \colorbold{Funktionsaufruf} dieser Funktion machen kann. Das ist notwendig, damit Fehlermeldungen ausgegeben können, wenn

\begin{Definition}{Funktionsprototyp}{funktionsprototyp}
  \colorbold{Deklaration} einer Funktion, welche den \colorbold{Funktionsbezeichner}, die \colorbold{Datentypen} der einzelnen \colorbold{Parameter}, die \colorbold{Parametereihenfolge} und den \colorbold{Rückgabewert} einer Funktion spezifiziert.\footnote{Der \colorbold{Funktionsprototyp} ist von der \colorbold{Funktionsignatur} zu unterschieden, die in Programmiersprache wie \smalltt{C++} und \smalltt{Java} für die \colorbold{Auflösung} von \colorbold{überladenen Methoden} verwendet wird und sich üblicherweise nicht für den \colorbold{Rückgabewert} interessiert.}\footcite{noauthor_what_nodate-4}.
\end{Definition}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1}}]{./code_examples/verbose_3_funs_fun_decl.picoc}
  \caption{PicoC-Code für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

Bei mehreren Funktionen werden die \colorbold{Scopes} der unterschiedlichen \colorbold{Funktionen} mittels eines \colorbold{Suffix} \smalltt{\dq <fun\_name>@\dq} umgesetzt, der an den \colorbold{Variablennamen} \smalltt{<var>} drangehängt wird: \smalltt{<var>@<fun\_name>}. Dieser \colorbold{Suffix} wird geändert sobald beim \colorbold{Top-Down}\footnote{D.h. von der Wurzel zu den Blättern eines Baumes} Durchiterieren über den \colorbold{Abstract Syntax Tree} des aktuellen \colorbold{Passes} nach dem \colorbold{Depth-First-Search} Schema über den

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={3-11, 34, 43}}]{./code_examples/verbose_3_funs_fun_decl.st}
  \caption{Symboltabelle für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

% Allocation von Variablen
% Stack und Globale Statische Daten
% die Sache mit Assign(Tmp, Global) und Assign(Global, Tmp)
% erwähnen, das Main Funktion keinen Stackframe hat
% zählen der Größe der lokalen Daten und Parameter
% TODO: Signatur zu Parameter umbenennen
\subsubsection{Funktionsaufruf}

\newlineparagraph{Ohne Rückgabewert}

% TODO: Betriebssysteme Vorlesung erwähnen auch in anderen Kapiteln

% Unsichtbares return
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_fun_call_no_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\newlineparagraph{Mit Rückgabewert}

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_fun_call_with_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\newlineparagraph{Umsetzung von Call by Sharing für Arrays}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,7}}]{./code_examples/verbose_fun_call_by_sharing_array.picoc}
  \caption{PicoC-Code für Call by Sharing für Arrays}
  \label{code:picoc_code_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-20}}]{./code_examples/verbose_fun_call_by_sharing_array.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Sharing für Arrays}
  \label{code:picoc_mon_pass_für_call_by_sharing_für_arrays}
\end{code}


% https://tex.stackexchange.com/questions/298383/how-to-highlight-color-draw-attention-to-a-particular-snippet-in-minted/498614#498614
\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15,24}}]{./code_examples/verbose_fun_call_by_sharing_array.st}
  \caption{Symboltabelle für Call by Sharing für Arrays}
  \label{code:symboltabelle_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-20}}]{./code_examples/verbose_fun_call_by_sharing_array.reti_blocks}
  \caption{RETI-Block Pass für Call by Sharing für Arrays}
  \label{code:reti_blocks_pass_für_call_by_sharing_für_arrays}
\end{code}

% die Sache mit dem erstetzen von ArryDecl durch PntrDecl

\newlineparagraph{Umsetzung von Call by Value für Structs}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8}}]{./code_examples/verbose_fun_call_by_value_struct.picoc}
  \caption{PicoC-Code für Call by Value für Structs}
  \label{code:picoc_code_für_call_by_value_für_structs}
\end{code}

% argmode für Struct Call by Value

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-19}}]{./code_examples/verbose_fun_call_by_value_struct.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Value für Structs}
  \label{code:picoc_mon_pass_für_call_by_value_for_structs}
\end{code}

% hier könnte man anmerken, dass die Adressen unterschiedlich berechnet werden für Stack und Globale...

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-19}}]{./code_examples/verbose_fun_call_by_value_struct.reti_blocks}
  \caption{RETI-Block Pass für Call by Value für Structs}
  \label{code:reti_blocks_pass_für_call_by_value_for_structs}
\end{code}

% Struct wird wirklich kopiert durch speziellen Argmode

% \subsection{Umsetzung kleinerer Details}
% langen Sprüngen, großen Konstanten, Division durch 0
\section{Fehlermeldungen}
\subsection{Error Handler}
\subsection{Arten von Fehlermeldungen}
\subsubsection{Syntaxfehler}
\subsubsection{Laufzeitfehler}
% Fehlermeldung ist, wenn der Lexer (partielle Funktion) oder Parser nicht matcht
% Token und Nodes enthalten Position, im Transformer wird die Position von den Token auf die Nodes übertragen und auch die Symboltabelle speichert Position
