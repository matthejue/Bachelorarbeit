%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1_Tables_DT_AST.tex,
% ./Implementierung2_Pntr_Array.tex,
% ./Implementierung3_Struct_Derived.tex,
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Funktionen}
\label{sec:umsetzung_von_funktionen}

\subsubsection{Mehrere Funktionen}
\label{sec:mehrere_funktionen}

Die Umsetzung \colorbold{mehrerer Funktionen} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_3_funktionen} erklärt. Dieses Beispiel soll nur zeigen, wie Funktionen in verschiedenen, für die Kompilierung von Funktionen relevanten \colorbold{Passes} kompiliert werden. Das Beispiel ist so gewählt, dass es möglichst \colorbold{isoliert} von weiterem möglicherweise störendem Code ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_3_funs.picoc}
  \caption{PicoC-Code für 3 Funktionen}
  \label{code:picoc_code_für_3_funktionen}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_3_Funktionen} wird eine \colorbold{Funktion}, wie z.B. \seqtt{void fun(int param;)\{\enspace return param;\enspace \}} mit der Komposition \smalltt{FunDef(IntType(), Name('fun'), [Alloc(Writeable(), IntType(), Name('fun'))], [Return(Exp(Name('param')))])} dargestellt. Die einzelnen \colorbold{Attribute} dieses Container-Knoten sind in Tabelle~\ref{tab:picoc_knoten_teil_4} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.ast}
  \caption{Abstract Syntax Tree für 3 Funktionen}
  \label{code:abstract_syntax_tree_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-Blocks Pass} in Code~\ref{code:picoc_blocks_pass_für_3_Funktionen} werden die \colorbold{Statements} der Funktion in \colorbold{Blöcke} \smalltt{Block(name, stmts\_instrs)} aufgeteilt. Dabei bekommt ein Block \smalltt{Block(name, stmts\_instrs)}, der die Statements der Funktion vom \colorbold{Anfang} bis zum \colorbold{Ende} oder bis zum Auftauchen eines \smalltt{If(exp, stmts)}, \smalltt{IfElse(exp, stmts1, stmts2)}, \smalltt{While(exp, stmts)} oder \smalltt{DoWhile(exp, stmts)}\footnote{Eine Erklärung dazu ist in Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} zu finden.} beinhaltet den \colorbold{Bezeichner} bzw. den \smalltt{Name(str)}-Token-Knoten der Funktion an sein \colorbold{Label} bzw. an sein \smalltt{name}-Attribut zugewiesen. Dem \colorbold{Bezeichner} wird vor der Zuweisung allerdings noch eine \colorbold{Nummer} angehängt \smalltt{<name>.<nummer>}\footnote{Der \colorbold{Grund} dafür kann im Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} nachgelesen werden.}.

Es werden parallel dazu neue Zuordnungen im \colorbold{Dictionary} \smalltt{fun\_name\_to\_block\_name} hinzugefügt. Das \colorbold{Dicionary} ordnet einem \colorbold{Funktionsnamen} den \colorbold{Blocknamen} des Blockes, der das erste \colorbold{Statement} der Funktion enthält und dessen \colorbold{Bezeichner} \smalltt{<name>.<nummer>} bis auf die angehängte \colorbold{Nummer} identisch zu dem der Funktion ist zu\footnote{Das ist der \colorbold{Block}, über den im \colorbold{obigen letzten Paragraph} gesprochen wurde.}. Diese Zuordnung ist nötig, da \colorbold{Blöcke} noch eine \colorbold{Nummer} an ihren Bezeichner \smalltt{<name>.<nummer>} angehängt haben.

% Dieser Pass hat allerdings keine direkte wichtige Bedeutung bei der Kompilierung von \colorbold{Funktionen}. Die Erwähnung dieses \colorbold{Pass} ist nur wichtig, weil nach diesem Pass die \colorbold{Statements} in \colorbold{Blöcke} aufgeteilt sind.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_blocks}
  \caption{PicoC-Blocks Pass für 3 Funktionen}
  \label{code:picoc_blocks_pass_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-ANF Pass} in Code~\ref{code:picoc_mon_pass_für_3_Funktionen} werden die \smalltt{FunDef(datatype, name, allocs, stmts)}-Container-Knoten komplett aufgelöst, sodass sich im \smalltt{File(name, decls\_defs\_blocks)}-Container-Knoten nur noch Blöcke befinden.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_mon}
  \caption{PicoC-ANF Pass für 3 Funktionen}
  \label{code:picoc_mon_pass_für_3_Funktionen}
\end{code}

Nach dem \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_3_Funktionen} gibt es nur noch \colorbold{RETI-Instructions}, die Blöcke wurden entfernt und die \colorbold{RETI-Instructions} in diesen Blöcken wurden genauso zusammengefügt, wie die Blöcke angeordnet waren. Ohne die \colorbold{Kommentare} könnte man die Funktionen nicht mehr direkt ausmachen, denn die \colorbold{Kommentare} enthalten die \colorbold{Labelbezeichner} \smalltt{<name>.<nummer>} der Blöcke, die in diesem Beispiel immer zugleich bis auf die Nummer, dem \colorbold{Namen} der jeweiligen \colorbold{Funktion} entsprechen.

Da es in der \smalltt{main}-Funktion keinen \colorbold{Funktionsaufruf} gab, wird der Code, der nach der \colorbold{Instruction} in der \colorbold{markierten Zeile} kommt nicht mehr betreten. Funktionen sind im \colorbold{RETI-Code} nur dadurch existent, dass im RETI-Code \colorbold{Sprünge} (z.B. \smalltt{JUMP<rel> <im>}) zu den jeweils richtigen Positionen gemacht werden, nämlich dorthin, wo die \colorbold{RETI-Instructions}, die aus den \colorbold{Statemtens} einer \colorbold{Funktion} kompiliert wurden anfangen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={6}}]{./code_examples/verbose_3_funs.reti}
  \caption{RETI-Blocks Pass für 3 Funktionen}
  \label{code:reti_pass_für_3_Funktionen}
\end{code}

% einfügen unsichtbarer Returns bei void
\newlineparagraph{Sprung zur Main Funktion}

Im vorherigen Beispiel in Code~\ref{code:picoc_code_für_3_funktionen} war die \smalltt{main}-Funktion die \colorbold{erste} Funktion, die im Code vorkam. Dadurch konnte die \smalltt{main}-Funktion direkt betreten werden, da die \colorbold{Ausführung} des Programmes immer ganz vorne im \colorbold{RETI-Code} beginnt. Man musste sich daher keine Gedanken darum machen, wie man die \colorbold{Ausführung}, die von der \smalltt{main}-Funktion ausgeht überhaupt startet.

Im Beispiel in Code~\ref{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} ist die \smalltt{main}-Funktion allerdings \colorbold{nicht} die \colorbold{erste} Funktion. Daher muss dafür gesorgt werden, dass die \smalltt{main}-Funktion die erste Funktion ist, die ausgeführt wird.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8-10}}]{./code_examples/verbose_3_funs_main.picoc}
  \caption{PicoC-Code für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} sind die \colorbold{Funktionen} nur noch durch \colorbold{Blöcke} umgesetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={23-28}}]{./code_examples/verbose_3_funs_main.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\colorbold{Eine simple Möglichkeit} ist es, die \smalltt{main-Funktion} einfach nach \colorbold{vorne} zu schieben, damit diese als \colorbold{erstes} ausgeführt wird. Im \smalltt{File(name, decls\_defs)}-Container-Knoten muss dazu im \smalltt{decls\_defs}-Attribut, welches eine \colorbold{Liste von Funktionen} ist, die \smalltt{main}-Funktion an Index $0$ geschoben werden.

\colorbold{Eine andere Möglichkeit} und die Möglichkeit für die sich in der \colorbold{Implementierung} des \colorbold{PicoC-Compilers} entschieden wurde, ist es, wenn die \smalltt{main}-Funktion nicht die erste auftauchende Funktion ist, einen \smalltt{start.<nummer>}-Block als ersten Block einzufügen, der einen \smalltt{GoTo(Name('main.<nummer>'))}-Container-Knoten enthält, der im \colorbold{RETI Pass}~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} in einen Sprung zur \smalltt{main}-Funktion übersetzt wird.

In der Implementierung des \colorbold{PicoC-Compilers} wurde sich für diese Möglichkeit entschieden, da es für \colorbold{Studenten}, welche die Verwender des \colorbold{PiocC-Compilers} sein werden vermutlich am \colorbold{intuitivsten} ist,  wenn der \colorbold{RETI-Code} für die Funktionen an denselben Stellen relativ zueinander verortet ist, wie die Funktionsdefinitionen im \colorbold{PicoC-Code}.

Das \colorbold{Einsetzen} des \smalltt{start.<nummer>}-Blockes erfolgt im \colorbold{RETI-Patch Pass} in Code~\ref{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}, da der \colorbold{RETI-Patch}-Pass der Pass ist, der für das \colorbold{Ausbessern} (engl. to patch) zuständig ist, wenn z.B. in manchen Fällen die \smalltt{main}-Funktion nicht die erste Funktion ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,29-34}}]{./code_examples/verbose_3_funs_main.reti_patch}
  \caption{RETI-Patch Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} wird das \smalltt{GoTo(Name('main.<nummer>'))} durch den entsprechenden \smalltt{Sprung} \smalltt{JUMP <distanz\_zur\_main\_funktion>} ersetzt und die Blöcke entfernt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={3,19}}]{./code_examples/verbose_3_funs_main.reti}
  \caption{RETI Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\subsubsection{Funktionsdeklaration und -definition und Umsetzung von Scopes}
\label{sec:funktionsdeklaration_und_definition_und_umsetzung_von_scopes}

In der Programmiersprache $L_C$ und somit auch $L_{PicoC}$ ist es notwendig, dass eine Funktion \colorbold{deklariert} ist, bevor man einen \colorbold{Funktionsaufruf} zu dieser Funktion machen kann. Das ist notwendig, damit \colorbold{Fehlermeldungen} ausgegeben werden können, wenn der \colorbold{Prototyp} (Definition~\ref{def:funktionsprototyp}) der Funktion nicht mit den \colorbold{Datentypen} der \colorbold{Argumente} oder der \colorbold{Anzahl} \colorbold{Argumente} übereinstimmt, die beim \colorbold{Funktionsaufruf} an die Funktion in einer \colorbold{festen} Reihenfolge übergeben werden.

Die Dekleration einer Funktion kann explizit erfolgen (z.B. \smalltt{int fun2(int var);}), wie in der im Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} \colorbold{markierten Zeile} \smalltt{1} oder zusammen mit der \colorbold{Funktionsdefinition} (z.B. \smalltt{void fun1()\{\}}), wie in den \colorbold{markierten Zeilen} \smalltt{3-4}.

In dem Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} erfolgt ein \colorbold{Funktionsaufruf} zur Funktion \smalltt{fun2}, die allerdings erst nach der \smalltt{main}-Funktion definiert ist. Daher ist eine \colorbold{Funktionsdekleration}, wie in der \colorbold{markierten Zeile} \smalltt{1} notwendig. Beim \colorbold{Funktionsaufruf} zur Funktion \smalltt{fun1} ist das \colorbold{nicht} notwendig, da die Funktion vorher \colorbold{definiert} wurde, wie in den \colorbold{markierten Zeilen} \smalltt{3-4} zu sehen ist.

\begin{Definition}{Funktionsprototyp}{funktionsprototyp}
  \colorbold{Deklaration} einer Funktion, welche den \colorbold{Funktionsbezeichner}, die \colorbold{Datentypen} der einzelnen \colorbold{Funktionsparameter}, die \colorbold{Parametereihenfolge} und den \colorbold{Rückgabewert} einer Funktion spezifiziert. Es ist \colorbold{nicht} möglich zwei Funktiondeklarationen mit dem \colorbold{gleichen} Funktionsbezeichner zu haben.\footnote{Der \colorbold{Funktionsprototyp} ist von der \colorbold{Funktionsignatur} zu unterschieden, die in Programmiersprache wie \smalltt{C++} und \smalltt{Java} für die \colorbold{Auflösung} von \colorbold{Überladung} bei z.B. \colorbold{Methoden} verwendet wird und sich in manchen Sprachen für den \colorbold{Rückgabewert} interessiert und in manchen nicht, je nach Umsetzung. In solchen Sprachen ist es möglich mehrere \colorbold{Methoden} oder \colorbold{Funktionen} mit dem \colorbold{gleichen} Bezeichner zu haben, solange sie sich durch die \colorbold{Datentpyen} von \colorbold{Parametern}, die \colorbold{Parameterreihenfolge}, manchmal auch \colorbold{Scopes} und \colorbold{Klassentpyen} usw. unterschieden.}\footcite{noauthor_what_nodate-4}
\end{Definition}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,3-4}}]{./code_examples/verbose_3_funs_fun_decl.picoc}
  \caption{PicoC-Code für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

Die \colorbold{Deklaration} einer \colorbold{Funktion} erfolgt mithilfe der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} für das Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} dargestellt ist. Die \colorbold{Attribute} des \colorbold{Symbols} \smalltt{Symbols(type\_qual, datatype, name, val\_addr, pos, size)} werden wie üblich gesetzt. Dem \smalltt{datatype}-Attribut wird dabei einfach die komplette Komposition der \colorbold{Funktionsdeklaration} \smalltt{FunDecl(IntType('int'), Name('fun2'), [Alloc(Writeable(), IntType('int'), Name('var'))])} zugewiesen.

Die Varaiblen \smalltt{var@main} und \smalltt{var@fun2} der \smalltt{main}-Funktion und der Funktion \smalltt{fun2} haben unterschiedliche \colorbold{Scopes} (Definition~\ref{def:scope}). Die \colorbold{Scopes} der \colorbold{Funktionen} werden mittels eines \colorbold{Suffix} \smalltt{\dq @<fun\_name>\dq} umgesetzt, der an den \colorbold{Bezeichner} \smalltt{var} drangehängt wird: \smalltt{var@<fun\_name>}. Dieser \colorbold{Suffix} wird geändert sobald beim \colorbold{Top-Down}\footnote{D.h. von der \colorbold{Wurzel} zu den \colorbold{Blättern} eines Baumes.} Durchiterieren über den \colorbold{Abstract Syntax Tree} des aktuellen \colorbold{Passes} ein \colorbold{Funktionswechsel} eintritt und über die Statements der nächsten Funktion iteriert wird, für die der \colorbold{Suffix} der neuen Funktion \smalltt{FunDef(name, datatype, params, stmts)} angehängt wird, der aus dem \smalltt{name}-Attribut entnommen wird.

Ein Grund, warum \colorbold{Scopes} über das Anhängen eines \colorbold{Suffix} an den \colorbold{Bezeichner} gelöst sind, ist, dass auf diese Weise die \colorbold{Schlüssel}, die aus dem \colorbold{Bezeichner} einer Variable und einem angehängten \colorbold{Suffix} bestehen, in der als \colorbold{Dictionary} umgesetzten \colorbold{Symboltabelle} eindeutig sind. Damit man einer Variable direkt den \colorbold{Scope} ablesen kann in dem sie definiert wurde, ist der \colorbold{Suffix} ebenfalls im \smalltt{Name(str)}-Token-Knoten des \smalltt{name}-Attribubtes eines \colorbold{Symbols} der Symboltabelle angehängt. Zur beseren Vorstellung ist dies ist in Code~\ref{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} \colorbold{markiert}.

Die Variable \smalltt{var@main}, bei der es sich um eine \colorbold{Lokale Variable} der \smalltt{main}-Funktion handelt, ist nur innerhalb des \colorbold{Codeblocks} \smalltt{\{\}} der \smalltt{main}-Funktion \colorbold{sichtbar} und die Variable \smalltt{var@fun2} bei der es sich im einen \colorbold{Parameter} handelt, ist nur innerhalb des \colorbold{Codeblocks} \smalltt{\{\}} der Funktion \smalltt{fun2} \colorbold{sichtbar}. Das ist dadurch umgesetzt, dass der \colorbold{Suffix}, der bei jedem \colorbold{Funktionswechsel} angepasst wird, auch beim Nachschlagen eines \colorbold{Symbols} in der \colorbold{Symboltabelle} an den \colorbold{Bezeichner} der Variablen, die man nachschlagen will angehängt wird. Und da die Zuordnungen im \colorbold{Dictionary} \colorbold{eindeutig} sind, kann eine Variable nur in genau der Funktion nachgeschlagen werden, in der sie \colorbold{definiert} wurde.

Das Zeichen \smalltt{'@'} wurde aus einem bestimmten Grund als \colorbold{Trennzeichen} verwendet, nämlich, weil kein Bezeichner das Zeichen \smalltt{'@'} jemals selbst enthalten kann. Damit ist ausgeschlossen, dass falls ein \colorbold{Benutzer} des \colorbold{PicoC-Compilers} zufällig auf die Idee kommt seine Funktion genauso zu nennen (z.B. \smalltt{var@fun2} als Funktionsname), es zu Problemen kommt, weil bei einem Nachschlagen der \colorbold{Variable} die \colorbold{Funktion} nachgeschlagen wird.

\begin{Definition}{Scope (bzw. Sichtbarkeitsbereich)}{scope}
  \colorbold{Bereich} in einem Programm, in dem eine Variable \colorbold{sichtbar} ist und \colorbold{verwendet} werden kann.\footcite{thiemann_einfuhrung_2018}
\end{Definition}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={34, 43}}]{./code_examples/verbose_3_funs_fun_decl.st}
  \caption{Symboltabelle für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

% Allocation von Variablen
% Stack und Globale Statische Daten
% die Sache mit Assign(Tmp, Global) und Assign(Global, Tmp)
% erwähnen, das Main Funktion keinen Stackframe hat
% zählen der Größe der lokalen Daten und Parameter
% TODO: Signatur zu Parameter umbenennen
\subsubsection{Funktionsaufruf}

Ein \colorbold{Funktionsaufruf} (z.B. \smalltt{stack\_fun(local\_var)}) wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_funktionsaufruf_ohne_rückgabewert} erklärt. Das Beispiel ist so gewählt, dass alleinig der \colorbold{Funktionsaufruf} im \colorbold{Vordergrund} steht und dieses Kapitel nicht auch noch mit z.B. Aspekten wie der Umsetzung eines \colorbold{Rückgabewertes} überladen ist. Der Aspekt der Umsetzung eines \colorbold{Rückgabewertes} wird erst im nächsten Unterkapitel~\ref{sec:rückgabewert} erklärt.

% TODO: Betriebssysteme Vorlesung erwähnen auch in anderen Kapiteln
% Automatisches einfügen eines Return-Statements

% Unsichtbares return
\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={7}}]{./code_examples/example_fun_call_no_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_funktionsaufruf_ohne_rückgabewert} wird ein \colorbold{Funktionsaufruf} \smalltt{stack\_fun(local\_var)} durch die \colorbold{Komposition} \smalltt{Exp(Call(Name('stack\_fun'), [Name('local\_var')]))} dargestellt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={31}}]{./code_examples/example_fun_call_no_return_value.ast}
  \caption{Abstract Syntax Tree für Funktionsaufruf ohne Rückgabewert}
  \label{code:abstract_syntax_tree_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

Im \colorbold{PicoC-ANF Pass} in Code~\ref{code:picoc_mon_pass_für_funktionsaufruf_ohne_rückgabewert} wird die Komposition \seqtt{Exp(Call(Name('stack\_fun'), [Name('local\_var')]))} durch die Kompositionen \seqtt{StackMalloc(Num('2'))}, \seqtt{Ref(Global(Num('0')))}, \seqtt{NewStackframe(Name('stack\_fun'), GoTo(Name('addr@next\_instr')))}, \seqtt{Exp(GoTo(Name('stack\_fun.0')))} und \seqtt{RemoveStackframe()} ersetzt, welche in den Tabellen~\ref{tab:kompositionen_von_picoc_knoten_und_reti_knoten_mit_besonderer_bedeutung} und \ref{tab:picoc_knoten_teil_1} genauer erklärt sind.

Der Container-Knoten \smalltt{StackMalloc(Num('2'))} ist notwendig, weil auf dem \colorbold{Stackframe} für den Wert des \smalltt{BAF}-Registers der \colorbold{aufrufenden Funktion} und die \colorbold{Rücksprungadresse} $2$ Speicherzellen Platz am \colorbold{Anfang} des \colorbold{Stackframes} gelassen werden muss. Das wird durch den Container-Knoten \smalltt{StackMalloc(Num('2'))} umgesetzt, indem das \smalltt{SP}-Register einfach um zwei Speicherzellen \colorbold{dekrementiert} wird und somit Speicher auf dem \colorbold{Stack} belegt wird\footnote{Wobei hier \dq \colorbold{reserviert}\dq besser passen würde.}.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={7-11}}]{./code_examples/example_fun_call_no_return_value.picoc_mon}
  \caption{PicoC-ANF Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert} werden die Kompositionen \seqtt{StackMalloc(Num('2'))}, \seqtt{Ref(Global(Num('0')))}, \seqtt{NewStackframe(Name('stack\_fun')}, \seqtt{GoTo(Name('addr@next\_instr')))}, \seqtt{Exp(GoTo(Name('stack\_fun.0')))} und \seqtt{RemoveStackframe()} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

Unter den \colorbold{RETI-Knoten} entsprechen die \colorbold{Kompostionen} \smalltt{LOADI ACC GoTo(Name('addr@next\_instr'))} und \smalltt{Exp(GoTo(Name('stack\_fun.0')))} noch keine fertigen \colorbold{RETI-Instructions} und werden später in dem für sie vorgesehenen \colorbold{RETI-Pass} passend ergänzt bzw. ersetzt.

% https://tex.stackexchange.com/questions/219445/line-break-in-texttt
Für den \colorbold{Bezeichner des Blocks} \smalltt{stack\_fun.0}  in der Komposition \smalltt{Exp(GoTo(Name('stack\_fun.0')))} wird im \colorbold{Dictionary} \smalltt{fun\_name\_to\_block\_name}\footnote{Dieses Dictionary wurde in Unterkapitel~\ref{sec:mehrere_funktionen} eingeführt.} mit dem Schlüssel \smalltt{stack\_fun}, dem \colorbold{Bezeichner der Funktion}, der im Container-Knoten \smalltt{NewStackframe(Name('stack\_fun'))} gespeichert ist nachgeschlagen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={8,10-13,15-22,24,26-28}}]{./code_examples/example_fun_call_no_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

Im \colorbold{RETI Pass} in Code~\ref{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert} wird nun der finale \colorbold{RETI-Code} erstellt. Eine Änderung, die direkt auffällt, ist, dass die \colorbold{RETI-Befehle} aus den \colorbold{Blöcken} nun zusammengefügt sind und es keine \colorbold{Blöcke} mehr gibt. Des Weiteren wird das \smalltt{GoTo(Name('addr@next\_instr'))} in der Komposition \smalltt{\smalltt{LOADI ACC GoTo(Name('addr@next\_instr'))}} nun durch die \colorbold{Adresse} des nächsten Befehls direkt nach dem dem Befehl \smalltt{JUMP 5}, der für den \colorbold{Sprung zur gewünschten Funktion} verantwortlich ist\footnote{Also der Befehl, der bisher durch die Komposition \smalltt{Exp(GoTo(Name('stack\_fun.0'))) dargestellt wurde.}} ersetzt: \smalltt{LOADI ACC 14}. Und auch der \colorbold{Container-Knoten}, der den Sprung \smalltt{Exp(GoTo(Name('stack\_fun.0')))} darstellt wird durch den \colorbold{Container-Knoten} \smalltt{JUMP 5} ersetzt.

Die \colorbold{Distanz} \smalltt{5} im \colorbold{RETI-Knoten} \smalltt{JUMP 5} wird mithilfe des \smalltt{instrs\_before}-Attribute des \colorbold{Zielblocks}, der den ersten Befehl der gewünschten Funktion enthält und des \colorbold{aktuellen Blocks}, in dem der \colorbold{RETI-Knoten} \smalltt{JUMP 5} enthalten ist berechnet.

Die \colorbold{relative Adresse} \smalltt{14} direkt nach dem Befehl \smalltt{JUMP 5} wird ebenfalls mithilfe des \smalltt{instrs\_before}-Attributs des \colorbold{aktuellen Blocks} berechnet. Es handelt sich bei bei \seqsplit{14} um eine \colorbold{relative Adresse}, die \colorbold{relativ} zum \smalltt{CS}-Register berechnet wird, welches im \colorbold{RETI-Interpreter} von einem \colorbold{Startprogramm} im \colorbold{EPROM} immer so gesetzt wird, dass es die \colorbold{Adresse} enthält, an der das \colorbold{Codesegment} anfängt.

% relativ zu CS
\begin{Special_Paragraph}
  Die Berechnung der \colorbold{Adresse} \smalltt{'<addr@next\_instr>'} (bzw. in der Formel $adr_{danach}$) des Befehls nach dem \colorbold{Sprung} \smalltt{JUMP <distanz>} für den Befehl \smalltt{LOADI ACC <addr@next\_instr>} erfolgt dabei mithilfe der folgenden Formel:
\begin{equation}
  adr_{danach} = \#Bef_{vor\,akt.\,Bl.} + idx + 4
  \label{eq:addr_next_instr}
\end{equation}
  wobei:
  \begin{itemize}
    \item es sich bei bei $adr_{danach}$ um eine \colorbold{relative Adresse} handelt, die \colorbold{relativ} zum \smalltt{CS}-Register berechnet wird.
    \item $\#Bef_{vor\,akt.\,Bl.} \hat=$ \colorbold{Anzahl} Befehle vor dem momentanen Block. Es handelt sich hierbei um ein \textcolor{gray!90!black}{verstecktes Attribut} \smalltt{instrs\_before} eines jeden \colorbold{Blockes} \smalltt{Block(name, stmts\_instrs, \textcolor{gray!90!black}{instrs\_before}, \textcolor{gray!90!black}{num\_instrs}, \textcolor{gray!90!black}{param\_size}, \textcolor{gray!90!black}{local\_vars\_size})}, welches im \colorbold{RETI-Patch}-Pass gesetzt wird. Der Grund dafür, dass das Zuweisen dieses \textcolor{gray!90!black}{versteckten Attributes} \smalltt{instrs\_before} im \colorbold{RETI-Patch} Pass erfolgt ist, weil erst im \colorbold{RETI-Patch} Pass die \colorbold{finale Anzahl} an Befehlen in einem Block feststeht, da im \colorbold{RETI-Patch} Pass \smalltt{GoTo()}'s entfernt werden, deren Sprung nur \colorbold{eine} Adresse weiterspringen würde. Die \colorbold{finale Anzahl} an Befehlen kann sich in diesem \colorbold{Pass} also noch ändern und steht erst nach diesem \colorbold{Pass} fest.
    \item $idx\; \hat=$ relativer Index des Befehls \smalltt{LOADI ACC <addr@next\_instr>} selbst im Block.
    \item $4\; \hat=$ \colorbold{Distanz}, die zwischen den in Code~\ref{code:reti_pass_für_funktionsaufruf_ohne_rückgabewert} markierten Befehlen \smalltt{LOADI ACC <im>} und \smalltt{JUMP <im>} liegt und noch \colorbold{eins} mehr, weil man ja zum nächsten Befehl will.
  \end{itemize}

  Die Berechnug der \colorbold{Distanz} \smalltt{<distanz>} für den Sprung \smalltt{JUMP <distanz>} zum \colorbold{ersten} Befehl eines im \colorbold{Pass} zuvor \colorbold{existenten Blockes} erfolgt dabei nach der folgenden Formel:
  % https://stackoverflow.com/questions/57820567/how-to-fit-very-long-line-in-case-bracket-equations-in-latex-with-double-column
  \begin{equation}
    distanz = \begin{dcases}
      -\#Bef_{vor\, akt.\, Bl.} + \#Bef_{vor\, Zielbl.} - idx & \#Bef_{vor\, Zielbl.} < \#Bef_{vor\, akt.\, Bl.} \\
      -idx & \#Bef_{vor\, Zielbl.} = \#Bef_{vor\, akt.\, Bl.} \\
      \#Bef_{vor\, Zielbl.} - \#Bef_{vor\, akt.\, Bl.} - idx & \#Bef_{vor\, Zielbl.} > \#Bef_{vor\, akt.\, Bl.}
    \end{dcases}
  \end{equation}
  wobei:
  \begin{itemize}
    \item $\#Bef_{vor\, Zielbl.} \hat=$ \colorbold{Anzahl} Befehle vor dem \colorbold{Zielblock}, der den \colorbold{ersten} Befehl einer Funktion enthält und zu dem gesprungen werden soll. Es handelt sich hierbei um ein \textcolor{gray!90!black}{verstecktes Attribut} \smalltt{instrs\_before} eines jeden \colorbold{Blockes} \smalltt{Block(name, stmts\_instrs, \textcolor{gray!90!black}{instrs\_before}, \textcolor{gray!90!black}{num\_instrs}, \textcolor{gray!90!black}{param\_size}, \textcolor{gray!90!black}{local\_vars\_size})}.
    \item $\#Bef_{vor\,akt.\,Bl.}$ und $idx$ haben die \colorbold{gleiche Bedeutung} wie in der Formel~\ref{eq:addr_next_instr}.
  \end{itemize}
\end{Special_Paragraph}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16,20}}]{./code_examples/example_fun_call_no_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\newlineparagraph{Rückgabewert}
\label{sec:rückgabewert}

Ein \colorbold{Funktionsaufruf inklusive Zuweisung eines Rückgabewertes} (z.B. \seqtt{int\; var\; =\; fun\_with\_return\_value()}) wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_funktionsaufruf_mit_rückgabewert} erklärt.
% todo: unsichtbare return statements

Um den Unterschied zwischen einem \smalltt{return} ohne \colorbold{Rückgabewert} und einem \smalltt{return 21 * 2} mit \colorbold{Rückgabewert} hervorzuheben, wurde ist auch eine Funktion \smalltt{fun\_no\_return\_value}, die \colorbold{keinen} Rückgabewert hat in das Beispiel integriert.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={2, 6, 10, 11}}]{./code_examples/example_fun_call_with_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_mit_rückgabewert}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_funktionsaufruf_mit_rückgabewert} wird ein \colorbold{Return-Statement mit Rückgabewert} \smalltt{return 21 * 2} mit der Komposition \smalltt{Return(BinOp(Num('21'), Mul('*'), Num('2')))} dargestellt, ein \colorbold{Return-Statement ohne Rückgabewert} \smalltt{return} mit der Komposition \smalltt{Return(Empty())} und ein \colorbold{Funktionsaufruf} inklusive \colorbold{Zuweisung des Rückgabewertes} \smalltt{int var = fun\_with\_return\_value()} durch die Komposition \seqtt{Assign(Alloc(Writeable(), IntType('int'), Name('var')), Call(Name('fun\_with\_return\_value'), []))}.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={9, 16, 23, 24}}]{./code_examples/example_fun_call_with_return_value.ast}
  \caption{Abstract Syntax Tree für Funktionsaufruf mit Rückgabewert}
  \label{code:abstract_syntax_tree_für_funktionsaufruf_mit_rückgabewert}
\end{code}

Im \colorbold{PicoC-ANF Pass} in Code~\ref{code:picoc_mon_pass_für_funktionsaufruf_mit_rückgabewert} wird bei der \colorbold{Komposition} \smalltt{Return(BinOp(Num('21'), Mul('*'), Num('2')))} erst die \colorbold{Expression} \smalltt{BinOp(Num('21'), Mul('*'), Num('2'))} ausgewertet. Die hierführ erstellten Kompositionen \smalltt{Exp(Num('21'))}, \smalltt{Exp(Num('2'))} und \smalltt{Exp(BinOp(Stack(Num('2')), Mul('*'), Stack(Num('1'))))} berechnen das Ergebnis des Ausdrucks \smalltt{21*2} auf dem \colorbold{Stack}. Dieses Ergebnis wird dann von der \colorbold{Komposition} \smalltt{Return(Stack(Num('1')))} vom \colorbold{Stack} gelesen und in das \colorbold{Register} \smalltt{ACC} geschrieben und als letztes wird die \colorbold{Rücksprungadresse} in  das \smalltt{PC}-Register geladen, die durch den \smalltt{NewStackframe()}-Token-Knoten eine Speicherzelle nach dem Wert des \smalltt{BAF}-Registers der aufrufenden Funktion im \colorbold{Stackframe} gespeichert ist.

Ein wichtiges Detail bei der \colorbold{Funktion} \smalltt{fun\_with\_return\_value} ist, dass der \colorbold{Funktionsaufruf} \smalltt{Call(Name('fun\_with\_return\_value'), []))} anders übersetzt wird, da die \colorbold{Funktion} einen Rückgabewert vom \colorbold{Datentyp} \smalltt{IntType()} und nicht \smalltt{VoidType()} hat. Um den \colorbold{Rückgabewert}, der durch die Komposition \smalltt{Return(BinOp(Num('21'), Mul('*'), Num('2')))} in das \smalltt{ACC}-Register geschrieben wurde für die aufrufende Funktion, deren Stackframe nun wieder das aktuelle ist auf den \colorbold{Stack} zu schreiben, muss ein neue \colorbold{Komposition} \smalltt{Exp(ACC)} definiert werden. In Tabelle~\ref{tab:kompositionen_von_picoc_knoten_und_reti_knoten_mit_besonderer_bedeutung} ist die \colorbold{Komposition} \smalltt{Exp(ACC)} genauer erklärt.

Dieser Trick mit dem Speichern des \colorbold{Rückgabewertes} im \smalltt{ACC}-Register ist notwendidg, weil durch das \colorbold{Entfernen} des \colorbold{Stackframes} der \colorbold{aufgerufenen Funktion} das \smalltt{SP}-Register nicht mehr an der gleichen Stelle steht. Daher sind alle \colorbold{temporären} Werte, die in der \colorbold{aufgerufenen Funktion} auf den \colorbold{Stack} geschrieben wurden unzugänglich, weil man nicht wissen kann, um wieviel die Adresse im \smalltt{SP}-Register verglichen zu vorher verschoben ist, weil der \colorbold{Stackframe} von unterschiedlichen \colorbold{aufgerufenen Funktionen} unterschiedlich  groß sein kann.

Die \colorbold{Komposition} \seqtt{Assign(Alloc(Writeable(), IntType('int'), Name('var')), Call(Name('fun\_with\_return\_value'), []))} wird nach dem \colorbold{allokieren} der Variable \smalltt{Name('var')} durch die Komposition \smalltt{Assign(Global(Num('0')), Stack(Num('1')))} ersetzt, welche den \colorbold{Rückgabewert} der Funktion \smalltt{Name('fun\_with\_return\_value')}, welcher durch die \colorbold{Komposition} \smalltt{Exp(Acc)} aus dem \smalltt{ACC}-Register auf den \colorbold{Stack} geschrieben wurde nun vom \colorbold{Stack} in die Speicherzelle der Variable \smalltt{Name('var')} speichert. Hierzu muss die \colorbold{Adresse} der Variable \smalltt{Name('var')} in der \colorbold{Symboltabelle} nachgeschlagen werden.

Die \colorbold{Komposition} \smalltt{Return(Empty())} für ein  \smalltt{return} \colorbold{ohne Rückgabewert} bleibt unverändert und stellt nur das Laden der \colorbold{Rücksprungsadresse} in das \smalltt{PC}-Register dar.

Des Weiteren ist zu beobachten, dass wenn bei einer Funktion mit dem \colorbold{Rückgabedatentyp} \smalltt{void} kein \smalltt{return}-Statement explizit ans Ende geschrieben wird, im \colorbold{PicoC-ANF Pass} eines hinzufügt wird in Form der \smalltt{Komposition} \smalltt{Return(Empty())}. Beim Nicht-Angeben im Falle eines Dantentyps, der \colorbold{nicht} \smalltt{void} ist, wird allerdings eine \smalltt{MissingReturn}-\colorbold{Fehlermeldung} ausgelöst.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={8-11, 16, 26, 31-32}}]{./code_examples/example_fun_call_with_return_value.picoc_mon}
  \caption{PicoC-ANF Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_funktionsaufruf_mit_rückgabewert} werden die Kompositionen \seqtt{Exp(Num('21'))}, \seqtt{Exp(Num('2'))}, \seqtt{Exp(BinOp(Stack(Num('2')), Mul('*'), Stack(Num('1'))))}, \seqtt{Return(Stack(Num('1')))} und \seqtt{Assign(Global(Num('0')), Stack(Num('1')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={9-11,13-15,17-21,23-25,31,55,79}}]{./code_examples/example_fun_call_with_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\newlineparagraph{Umsetzung von Call by Sharing für Arrays}

Die \colorbold{Call by Reference} (Definition~\ref{def:call_by_reference}) Übergabe eines Arrays an eine andere Funktion, wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_call_by_sharing_für_arrays} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,4,5,10}}]{./code_examples/example_fun_call_by_sharing_array.picoc}
  \caption{PicoC-Code für Call by Sharing für Arrays}
  \label{code:picoc_code_für_call_by_sharing_für_arrays}
\end{code}

Im \colorbold{PicoC-ANF Pass} wird im Fall dessen, dass der \colorbold{oberste Container-Knoten} im Teilbaum, der den Datentyp darstellt und an die Funktion übergeben wird ein \colorbold{Array} \smalltt{ArrayDecl(nums, datatype)} ist, dieser zu einem \colorbold{Pointer} \smalltt{PntrDecl(num, datatype)} umgewandelt und der Rest des Teilbaumes, der am \smalltt{datatype}-Attribut hängt, an das \smalltt{datatype}-Attribut des \colorbold{Pointers} \smalltt{PntrDecl(num, datatype)} drangehängt.

Diese \colorbold{Umwandlung} des \colorbold{Datentyps} kann in der \colorbold{Symboltabelle} in Code~\ref{code:symboltabelle_für_call_by_sharing_für_arrays} beobachtet werden. Die \colorbold{lokalen Variablen} \smalltt{local\_var@main} und \smalltt{local\_var@fun\_array\_from\_global\_data} sind beide vom Datentyp \smalltt{ArrayDecl([Num('2'), Num('3')], IntType('int'))} und bei der Übergabe ändert sich der Datentyp beider Variablen zu \smalltt{PntrDecl(Num('1'), ArrayDecl([Num('3')], IntType('int')))}. Die \colorbold{Größe} dieser Variablen ändert sich damit zu \smalltt{Num('1')}, da ein  \colorbold{Pointer} nur eine \colorbold{Speicherzelle} braucht.

% https://tex.stackexchange.com/questions/298383/how-to-highlight-color-draw-attention-to-a-particular-snippet-in-minted/498614#498614
\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15,19,33,37,42,46,60,64}}]{./code_examples/example_fun_call_by_sharing_array.st}
  \caption{Symboltabelle für Call by Sharing für Arrays}
  \label{code:symboltabelle_für_call_by_sharing_für_arrays}
\end{code}

Im \colorbold{PicoC-ANF Pass} in Code~\ref{code:picoc_mon_pass_für_call_by_sharing_für_arrays} ist zu sehen, dass zur Übergabe der beiden Arrays die \colorbold{Adresse} der Arrays auf den \colorbold{Stack} geschrieben wird. Die \colorbold{Adresse} der beiden Arrays auf den \colorbold{Stack} zu schreiben wird durch die Kompositionen \smalltt{Ref(Global(Num('0')))} und \smalltt{Ref(Stackframe(Num('6')))} repräsentiert.

Die Komposition \smalltt{Ref(Global(Num('0')))} ist für Variablen in den \colorbold{Globalen Statischen Daten} und die Komposition \smalltt{Ref(Stackframe(Num('6')))} ist für Variablen aus dem \colorbold{Stackframe}. Dabei stellen die Zahlen in den \colorbold{Container-Knoten} \smalltt{Global(num)} bzw. \smalltt{Stackframe(num)} die \colorbold{relative Adressen} relativ zum \smalltt{DS}-Register bzw. \smalltt{SP}-Register dar, die aus der \colorbold{Symboltabelle} entnommen sind.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13,23}}]{./code_examples/example_fun_call_by_sharing_array.picoc_mon}
  \caption{PicoC-ANF Pass für Call by Sharing für Arrays}
  \label{code:picoc_mon_pass_für_call_by_sharing_für_arrays}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_call_by_sharing_für_arrays} werden Kompositionen \smalltt{Ref(Global(Num('0')))} und \smalltt{Ref(Stackframe(Num('6')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16-19,44-47}}]{./code_examples/example_fun_call_by_sharing_array.reti_blocks}
  \caption{RETI-Block Pass für Call by Sharing für Arrays}
  \label{code:reti_blocks_pass_für_call_by_sharing_für_arrays}
\end{code}

% die Sache mit dem erstetzen von ArryDecl durch PntrDecl

\newlineparagraph{Umsetzung von Call by Value für Structs}

Die \colorbold{Call by Value} (Definition~\ref{def:call_by_value}) Übergabe eines \colorbold{Structs} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_call_by_value_für_structs} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={4,7,8,14}}]{./code_examples/example_fun_call_by_value_struct.picoc}
  \caption{PicoC-Code für Call by Value für Structs}
  \label{code:picoc_code_für_call_by_value_für_structs}
\end{code}

Im \colorbold{PicoC-ANF Pass} in Code~\ref{code:picoc_mon_pass_für_call_by_value_for_structs} wird zur \colorbold{Übergabe eines Struct}, das komplette Struct auf den \colorbold{Stack} kopiert. Das wird mittels der Komposition \smalltt{Assign(Stack(Num('3')), Global(Num('0')))} bzw. der Komposition \smalltt{Assign(Stack(Num('3')), Stackframe(Num('2')))} dargestellt.

Bei der \colorbold{Übergabe} an eine \colorbold{Funktion} wird der Zugriff auf ein gesamtes \colorbold{Struct} anders gehandhabt als sonst. Normalerweise wird beim Zugriff auf ein Struct die \colorbold{Adresse} des \colorbold{ersten Attributs} dieses Strcuts auf den \colorbold{Stack} geschrieben. Bei der \colorbold{Übergabe an eine Funktion} wird dagegen das gesamte \colorbold{Strcut} auf den \colorbold{Stack} kopiert.

Das wird durch eine Variable \smalltt{argmode\_on} implementiert, die auf \smalltt{true} gesetzt wird, solange der \colorbold{Funktionsaufruf} im \colorbold{Picoc-ANF Pass} verarbeitet wird und wieder auf \smalltt{false} gesetzt, wenn die Verarbeitung des \colorbold{Funktionaufrufs} abgeschlossen ist. Solange die Variable \smalltt{argmode\_on} auf \smalltt{true} gesetzt ist, wird immer die Komposition \smalltt{Assign(Stack(Num('3')), Global(Num('0')))} bzw. der Komposition \smalltt{Assign(Stack(Num('3')), Stackframe(Num('2')))} für die Ersetzung verwendet. Ist die Varaible \smalltt{argmode\_on} auf \smalltt{false} wird die Komposition \smalltt{Ref(Globalnum())} bzw. \smalltt{Ref(Stackframe(num))} für die Ersetzung verwendet.

Die Komposition \smalltt{Assign(Stack(Num('3')), Stackframe(Num('2')))} wird im Falle dessen, dass die Structvariable in den \colorbold{Globalen Statischen Daten} liegt verwendet und die Komposition \smalltt{Assign(Stack(Num('3')), Global(Num('0')))} wird im Falle, dessen, dass die Structvariable im \colorbold{Stackframe} liegt verwendet.

% argmode für Struct Call by Value

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13,23}}]{./code_examples/example_fun_call_by_value_struct.picoc_mon}
  \caption{PicoC-ANF Pass für Call by Value für Structs}
  \label{code:picoc_mon_pass_für_call_by_value_for_structs}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_call_by_value_for_structs} werden die Kompositionen \smalltt{Assign(Stack(Num('3')), Stackframe(Num('2')))} und \smalltt{Assign(Stack(Num('3')), Global(Num('0')))} durch ihre entsprechenden \colorbold{RETI-Knoten} ersetzt.
% hier könnte man anmerken, dass die Adressen unterschiedlich berechnet werden für Stack und Globale...

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={16-22,47-53}}]{./code_examples/example_fun_call_by_value_struct.reti_blocks}
  \caption{RETI-Block Pass für Call by Value für Structs}
  \label{code:reti_blocks_pass_für_call_by_value_for_structs}
\end{code}

% Struct wird wirklich kopiert durch speziellen Argmode

% \subsection{Umsetzung kleinerer Details}
% langen Sprüngen, großen Konstanten, Division durch 0
\section{Fehlermeldungen}
\subsection{Error Handler}
\subsection{Arten von Fehlermeldungen}
\subsubsection{Syntaxfehler}
\subsubsection{Laufzeitfehler}
% Fehlermeldung ist, wenn der Lexer (partielle Funktion) oder Parser nicht matcht
% Token und Nodes enthalten Position, im Transformer wird die Position von den Token auf die Nodes übertragen und auch die Symboltabelle speichert Position
