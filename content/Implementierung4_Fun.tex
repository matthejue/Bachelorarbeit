%!Tex Root = ../Main.tex
% ./Packete_und_Deklarationen.tex
% ./Titlepage.tex
% ./Motivation.tex
% ./Einführung.tex
% ./Implementierung1_Tables_DT_AST.tex,
% ./Implementierung2_Pntr_Array.tex,
% ./Implementierung3_Struct_Derived.tex,
% ./Ergebnisse_und_Ausblick.tex

\subsection{Umsetzung von Funktionen}
\label{sec:umsetzung_von_funktionen}

\subsubsection{Mehrere Funktionen}

Die Umsetzung \colorbold{mehrerer Funktionen} wird im Folgenden mithilfe des Beispiels in Code~\ref{code:picoc_code_für_3_funktionen} erklärt. Dieses Beispiel soll nur zeigen, wie Funktionen in verschiedenen, für die Kompilierung von Funktionen relevanten \colorbold{Passes} kompiliert werden. Das Beispiel ist so gewählt, dass es möglichst \colorbold{isoliert} von weiterem möglicherweise störendem Code ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_3_funs.picoc}
  \caption{PicoC-Code für 3 Funktionen}
  \label{code:picoc_code_für_3_funktionen}
\end{code}

Im \colorbold{Abstract Syntax Tree} in Code~\ref{code:abstract_syntax_tree_für_3_Funktionen} wird eine \colorbold{Funktion}, wie z.B. \smalltt{void fun(int param;)\{\enspace return param;\enspace \}} mit der Komposition \smalltt{FunDef(IntType(), Name('fun'), [Alloc(Writeable(), IntType(), Name('fun'))], [Return(Exp(Name('param')))])} dargestellt. Die einzelnen \colorbold{Attribute} dieses Container-Knoten sind in Tabelle~\ref{tab:picoc_knoten_teil_4} erklärt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.ast}
  \caption{Abstract Syntax Tree für 3 Funktionen}
  \label{code:abstract_syntax_tree_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-Blocks Pass} in Code~\ref{code:picoc_blocks_pass_für_3_Funktionen} werden die \colorbold{Statements} der Funktion in \colorbold{Blöcke} \smalltt{Block(name, stmts\_instrs)} aufgeteilt. Dabei bekommt ein Block \smalltt{Block(name, stmts\_instrs)}, der die Statements der Funktion vom \colorbold{Anfang} bis zum \colorbold{Ende} oder bis zum Auftauchen eines \smalltt{If(exp, stmts)}, \smalltt{IfElse(exp, stmts1, stmts2)}, \smalltt{While(exp, stmts)} oder \smalltt{DoWhile(exp, stmts)}\footnote{Eine Erklärung dazu ist in Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} zu finden.} beinhaltet den \colorbold{Bezeichner} bzw. den \smalltt{Name(str)}-Token-Knoten der Funktion an sein \colorbold{Label} bzw. an sein \smalltt{name}-Attribut zugewiesen. Dem \colorbold{Bezeichner} wird vor der Zuweisung allerdings noch eine \colorbold{Nummer} angehängt \smalltt{<name>.<nummer>}\footnote{Der \colorbold{Grund} dafür kann im Unterkapitel~\ref{sec:picoc_blocks_pass_zweck} nachgelesen werden.}.

Es werden parallel dazu neue Zuordnungen im \colorbold{Dictionary} \smalltt{fun\_name\_to\_block\_name} hinzugefügt. Das \colorbold{Dicionary} ordnet einem \colorbold{Funktionsnamen} den \colorbold{Blocknamen} des Blockes, der das erste \colorbold{Statement} der Funktion enthält und dessen \colorbold{Bezeichner} \smalltt{<name>.<nummer>} bis auf die angehängte \colorbold{Nummer} identisch zu dem der Funktion ist zu\footnote{Das ist der \colorbold{Block}, über den im \colorbold{obigen letzten Paragraph} gesprochen wurde.}. Diese Zuordnung ist nötig, da \colorbold{Blöcke} noch eine \colorbold{Nummer} an ihren Bezeichner \smalltt{<name>.<nummer>} angehängt haben.

% Dieser Pass hat allerdings keine direkte wichtige Bedeutung bei der Kompilierung von \colorbold{Funktionen}. Die Erwähnung dieses \colorbold{Pass} ist nur wichtig, weil nach diesem Pass die \colorbold{Statements} in \colorbold{Blöcke} aufgeteilt sind.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_blocks}
  \caption{PicoC-Blocks Pass für 3 Funktionen}
  \label{code:picoc_blocks_pass_für_3_Funktionen}
\end{code}

Im \colorbold{PicoC-Mon Pass} in Code~\ref{code:picoc_mon_pass_für_3_Funktionen} werden die \smalltt{FunDef(datatype, name, allocs, stmts)}-Container-Knoten komplett aufgelöst, sodass sich im \smalltt{File(name, decls\_defs\_blocks)}-Container-Knoten nur noch Blöcke befinden.

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_3_funs.picoc_mon}
  \caption{PicoC-Mon Pass für 3 Funktionen}
  \label{code:picoc_mon_pass_für_3_Funktionen}
\end{code}

Nach dem \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_3_Funktionen} gibt es nur noch \colorbold{RETI-Instructions}, die Blöcke wurden entfernt und die \colorbold{RETI-Instructions} in diesen Blöcken wurden genauso zusammengefügt, wie die Blöcke angeordnet waren. Ohne die \colorbold{Kommentare} könnte man die Funktionen nicht mehr direkt ausmachen, denn die \colorbold{Kommentare} enthalten die \colorbold{Labelbezeichner} \smalltt{<name>.<nummer>} der Blöcke, die in diesem Beispiel immer zugleich bis auf die Nummer, dem \colorbold{Namen} der jeweiligen \colorbold{Funktion} entsprechen.

Da es in der \smalltt{main}-Funktion keinen \colorbold{Funktionsaufruf} gab, wird der Code, der nach der \colorbold{Instruction} in der \colorbold{markierten Zeile} kommt nicht mehr betreten. Funktionen sind im \colorbold{RETI-Code} nur dadurch existent, dass im RETI-Code \colorbold{Sprünge} (z.B. \smalltt{JUMP<rel> <im>}) zu den jeweils richtigen Positionen gemacht werden, nämlich dorthin, wo die \colorbold{RETI-Instructions}, die aus den \colorbold{Statemtens} einer \colorbold{Funktion} kompiliert wurden anfangen.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={6}}]{./code_examples/verbose_3_funs.reti}
  \caption{RETI-Blocks Pass für 3 Funktionen}
  \label{code:reti_pass_für_3_Funktionen}
\end{code}

% einfügen unsichtbarer Returns bei void
\newlineparagraph{Sprung zur Main Funktion}

Im vorherigen Beispiel in Code~\ref{code:picoc_code_für_3_funktionen} war die \smalltt{main}-Funktion die \colorbold{erste} Funktion, die im Code vorkam. Dadurch konnte die \smalltt{main}-Funktion direkt betreten werden, da die \colorbold{Ausführung} des Programmes immer ganz vorne im \colorbold{RETI-Code} beginnt. Man musste sich daher keine Gedanken darum machen, wie man die \colorbold{Ausführung}, die von der \smalltt{main}-Funktion ausgeht überhaupt startet.

Im Beispiel in Code~\ref{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} ist die \smalltt{main}-Funktion allerdings \colorbold{nicht} die \colorbold{erste} Funktion. Daher muss dafür gesorgt werden, dass die \smalltt{main}-Funktion die erste Funktion ist, die ausgeführt wird.

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8-10}}]{./code_examples/verbose_3_funs_main.picoc}
  \caption{PicoC-Code für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:picoc_code_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI-Blocks Pass} in Code~\ref{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} sind die \colorbold{Funktionen} nur noch durch \colorbold{Blöcke} umgesetzt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={23-28}}]{./code_examples/verbose_3_funs_main.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_blocks_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\colorbold{Eine simple Möglichkeit} ist es, die \smalltt{main-Funktion} einfach nach \colorbold{vorne} zu schieben, damit diese als \colorbold{erstes} ausgeführt wird. Im \smalltt{File(name, decls\_defs)}-Container-Knoten muss dazu im \smalltt{decls\_defs}-Attribut, welches eine \colorbold{Liste von Funktionen} ist, die \smalltt{main}-Funktion an Index $0$ geschoben werden.

\colorbold{Eine andere Möglichkeit} und die Möglichkeit für die sich in der \colorbold{Implementierung} des \colorbold{PicoC-Compilers} entschieden wurde, ist es, wenn die \smalltt{main}-Funktion nicht die erste auftauchende Funktion ist, einen \smalltt{start.<nummer>}-Block als ersten Block einzufügen, der einen \smalltt{GoTo(Name('main.<nummer>'))}-Container-Knoten enthält, der im \colorbold{RETI Pass}~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} in einen Sprung zur \smalltt{main}-Funktion übersetzt wird.

In der Implementierung des \colorbold{PicoC-Compilers} wurde sich für diese Möglichkeit entschieden, da es für \colorbold{Studenten}, welche die Verwender des \colorbold{PiocC-Compilers} sein werden vermutlich am \colorbold{intuitivsten} ist,  wenn der \colorbold{RETI-Code} für die Funktionen an denselben Stellen relativ zueinander verortet ist, wie die Funktionsdefinitionen im \colorbold{PicoC-Code}.

Das \colorbold{Einsetzen} des \smalltt{start.<nummer>}-Blockes erfolgt im \colorbold{RETI-Patch Pass} in Code~\ref{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}, da der \colorbold{RETI-Patch}-Pass der Pass ist, der für das \colorbold{Ausbessern} (engl. to patch) zuständig ist, wenn z.B. in manchen Fällen die \smalltt{main}-Funktion nicht die erste Funktion ist.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={4-9,29-34}}]{./code_examples/verbose_3_funs_main.reti_patch}
  \caption{RETI-Patch Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_patch_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

Im \colorbold{RETI Pass} in Code~\ref{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist} wird das \smalltt{GoTo(Name('main.<nummer>'))} durch den entsprechenden \smalltt{Sprung} \smalltt{JUMP <distanz\_zur\_main\_funktion>} ersetzt und die Blöcke entfernt.

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={3,19}}]{./code_examples/verbose_3_funs_main.reti}
  \caption{RETI Pass für Funktionen, wobei die main Funktion nicht die erste Funktion ist}
  \label{code:reti_pass_für_funktionen_wobei_die_main_funktion_nicht_die_erste_Funktion_ist}
\end{code}

\subsubsection{Funktionsdeklaration und -definition und Umsetzung von Scopes}

In der Programmiersprache $L_C$ und somit auch $L_{PicoC}$ ist es notwendig, dass eine Funktion \colorbold{deklariert} ist, bevor man einen \colorbold{Funktionsaufruf} zu dieser Funktion machen kann. Das ist notwendig, damit \colorbold{Fehlermeldungen} ausgegeben werden können, wenn der \colorbold{Prototyp} (Definition~\ref{def:funktionsprototyp}) der Funktion nicht mit den \colorbold{Datentypen} der \colorbold{Argumente} oder der \colorbold{Anzahl} \colorbold{Argumente} übereinstimmt, die beim \colorbold{Funktionsaufruf} an die Funktion in einer \colorbold{festen} Reihenfolge übergeben werden.

Die Dekleration einer Funktion kann explizit erfolgen (z.B. \smalltt{int fun2(int var);}), wie in der im Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} \colorbold{markierten Zeile} \smalltt{1} oder zusammen mit der \colorbold{Funktionsdefinition} (z.B. \smalltt{void fun1()\{\}}), wie in den \colorbold{markierten Zeilen} \smalltt{3-4}.

In dem Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} erfolgt ein \colorbold{Funktionsaufruf} zur Funktion \smalltt{fun2}, die allerdings erst nach der \smalltt{main}-Funktion definiert ist. Daher ist eine \colorbold{Funktionsdekleration}, wie in der \colorbold{markierten Zeile} \smalltt{1} notwendig. Beim \colorbold{Funktionsaufruf} zur Funktion \smalltt{fun1} ist das \colorbold{nicht} notwendig, da die Funktion vorher \colorbold{definiert} wurde, wie in den \colorbold{markierten Zeilen} \smalltt{3-4} zu sehen ist.

\begin{Definition}{Funktionsprototyp}{funktionsprototyp}
  \colorbold{Deklaration} einer Funktion, welche den \colorbold{Funktionsbezeichner}, die \colorbold{Datentypen} der einzelnen \colorbold{Funktionsparameter}, die \colorbold{Parametereihenfolge} und den \colorbold{Rückgabewert} einer Funktion spezifiziert. Es ist \colorbold{nicht} möglich zwei Funktiondeklarationen mit dem \colorbold{gleichen} Funktionsbezeichner zu haben.\footnote{Der \colorbold{Funktionsprototyp} ist von der \colorbold{Funktionsignatur} zu unterschieden, die in Programmiersprache wie \smalltt{C++} und \smalltt{Java} für die \colorbold{Auflösung} von \colorbold{Überladung} bei z.B. \colorbold{Methoden} verwendet wird und sich in manchen Sprachen für den \colorbold{Rückgabewert} interessiert und in manchen nicht, je nach Umsetzung. In solchen Sprachen ist es möglich mehrere \colorbold{Methoden} oder \colorbold{Funktionen} mit dem \colorbold{gleichen} Bezeichner zu haben, solange sie sich durch die \colorbold{Datentpyen} von \colorbold{Parametern}, die \colorbold{Parameterreihenfolge}, manchmal auch \colorbold{Scopes} und \colorbold{Klassentpyen} usw. unterschieden.}\footcite{noauthor_what_nodate-4}
\end{Definition}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,3-4}}]{./code_examples/verbose_3_funs_fun_decl.picoc}
  \caption{PicoC-Code für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

Die \colorbold{Deklaration} einer \colorbold{Funktion} erfolgt mithilfe der \colorbold{Symboltabelle}, die in Code~\ref{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} für das Beispiel in Code~\ref{code:picoc_code_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} dargestellt ist. Die \colorbold{Attribute} des \colorbold{Symbols} \smalltt{Symbols(type\_qual, datatype, name, val\_addr, pos, size)} werden wie üblich gesetzt. Dem \smalltt{datatype}-Attribut wird dabei einfach die komplette Komposition der \colorbold{Funktionsdeklaration} \smalltt{FunDecl(IntType('int'), Name('fun2'), [Alloc(Writeable(), IntType('int'), Name('var'))])} zugewiesen.

Die Varaiblen \smalltt{var@main} und \smalltt{var@fun2} der \smalltt{main}-Funktion und der Funktion \smalltt{fun2} haben unterschiedliche \colorbold{Scopes} (Definition~\ref{def:scope}). Die \colorbold{Scopes} der \colorbold{Funktionen} werden mittels eines \colorbold{Suffix} \smalltt{\dq @<fun\_name>\dq} umgesetzt, der an den \colorbold{Bezeichner} \smalltt{var} drangehängt wird: \smalltt{var@<fun\_name>}. Dieser \colorbold{Suffix} wird geändert sobald beim \colorbold{Top-Down}\footnote{D.h. von der \colorbold{Wurzel} zu den \colorbold{Blättern} eines Baumes} Durchiterieren über den \colorbold{Abstract Syntax Tree} des aktuellen \colorbold{Passes} ein \colorbold{Funktionswechsel} eintritt und über die Statements der nächsten Funktion iteriert wird, für die der \colorbold{Suffix} der neuen Funktion \smalltt{FunDef(name, datatype, params, stmts)} angehängt wird, der aus dem \smalltt{name}-Attribut entnommen wird.

Ein Grund, warum \colorbold{Scopes} über das Anhängen eines \colorbold{Suffix} an den \colorbold{Bezeichner} gelöst sind, ist, dass auf diese Weise die \colorbold{Schlüssel}, die aus dem \colorbold{Bezeichner} einer Variable und einem angehängten \colorbold{Suffix} bestehen, in der als \colorbold{Dictionary} umgesetzten \colorbold{Symboltabelle} eindeutig sind. Damit man einer Variable direkt den \colorbold{Scope} ablesen kann in dem sie definiert wurde, ist der \colorbold{Suffix} ebenfalls im \smalltt{Name(str)}-Token-Knoten des \smalltt{name}-Attribubtes eines \colorbold{Symbols} der Symboltabelle angehängt. Zur beseren Vorstellung ist dies ist in Code~\ref{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss} \colorbold{markiert}.

Die Variable \smalltt{var@main}, bei der es sich um eine \colorbold{Lokale Variable} der \smalltt{main}-Funktion handelt, ist nur innerhalb des \colorbold{Codeblocks} \smalltt{\{\}} der \smalltt{main}-Funktion \colorbold{sichtbar} und die Variable \smalltt{var@fun2} bei der es sich im einen \colorbold{Parameter} handelt, ist nur innerhalb des \colorbold{Codeblocks} \smalltt{\{\}} der Funktion \smalltt{fun2} \colorbold{sichtbar}. Das ist dadurch umgesetzt, dass der \colorbold{Suffix}, der bei jedem \colorbold{Funktionswechsel} angepasst wird, auch beim Nachschlagen eines \colorbold{Symbols} in der \colorbold{Symboltabelle} an den \colorbold{Bezeichner} der Variablen, die man nachschlagen will angehängt wird. Und da die Zuordnungen im \colorbold{Dictionary} \colorbold{eindeutig} sind, kann eine Variable nur in genau der Funktion nachgeschlagen werden, in der sie \colorbold{definiert} wurde.

Das Zeichen \smalltt{'@'} wurde aus einem bestimmten Grund als \colorbold{Trennzeichen} verwendet, nämlich, weil kein Bezeichner das Zeichen \smalltt{'@'} jemals selbst enthalten kann. Damit ist ausgeschlossen, dass falls ein \colorbold{Benutzer} des \colorbold{PicoC-Compilers} zufällig auf die Idee kommt seine Funktion genauso zu nennen (z.B. \smalltt{var@fun2} als Funktionsname), es zu Problemen kommt, weil bei einem Nachschlagen der \colorbold{Variable} die \colorbold{Funktion} nachgeschlagen wird.

\begin{Definition}{Scope (bzw. Sichtbarkeitsbereich)}{scope}
  \colorbold{Bereich} in einem Programm, in dem eine Variable \colorbold{sichtbar} ist und \colorbold{verwendet} werden kann.\footcite{thiemann_einfuhrung_2018}
\end{Definition}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={34, 43}}]{./code_examples/verbose_3_funs_fun_decl.st}
  \caption{Symboltabelle für Funktionen, wobei eine Funktion vorher deklariert werden muss}
  \label{code:symboltabelle_für_funktionen_picoc_code_für_funktionen_wobei_eine_funktion_vorher_deklariert_werden_muss}
\end{code}

% Allocation von Variablen
% Stack und Globale Statische Daten
% die Sache mit Assign(Tmp, Global) und Assign(Global, Tmp)
% erwähnen, das Main Funktion keinen Stackframe hat
% zählen der Größe der lokalen Daten und Parameter
% TODO: Signatur zu Parameter umbenennen
\subsubsection{Funktionsaufruf}

\newlineparagraph{Ohne Rückgabewert}

% TODO: Betriebssysteme Vorlesung erwähnen auch in anderen Kapiteln

% Unsichtbares return
\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_fun_call_no_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_no_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf ohne Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_ohne_rückgabewert}
\end{code}

\newlineparagraph{Mit Rückgabewert}

% todo: unsichtbare return statements

\begin{code}
  \centering
  \numberedcodebox[minted language=c]{./code_examples/verbose_fun_call_with_return_value.picoc}
  \caption{PicoC-Code für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_code_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.picoc_mon}
  \caption{PicoC-Mon Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:picoc_mon_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.reti_blocks}
  \caption{RETI-Blocks Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_blocks_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text]{./code_examples/verbose_fun_call_with_return_value.reti}
  \caption{RETI-Pass für Funktionsaufruf mit Rückgabewert}
  \label{code:reti_pass_für_funktionsaufruf_mit_rückgabewert}
\end{code}

\newlineparagraph{Umsetzung von Call by Sharing für Arrays}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={1,7}}]{./code_examples/verbose_fun_call_by_sharing_array.picoc}
  \caption{PicoC-Code für Call by Sharing für Arrays}
  \label{code:picoc_code_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-20}}]{./code_examples/verbose_fun_call_by_sharing_array.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Sharing für Arrays}
  \label{code:picoc_mon_pass_für_call_by_sharing_für_arrays}
\end{code}


% https://tex.stackexchange.com/questions/298383/how-to-highlight-color-draw-attention-to-a-particular-snippet-in-minted/498614#498614
\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15,24}}]{./code_examples/verbose_fun_call_by_sharing_array.st}
  \caption{Symboltabelle für Call by Sharing für Arrays}
  \label{code:symboltabelle_für_call_by_sharing_für_arrays}
\end{code}

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-20}}]{./code_examples/verbose_fun_call_by_sharing_array.reti_blocks}
  \caption{RETI-Block Pass für Call by Sharing für Arrays}
  \label{code:reti_blocks_pass_für_call_by_sharing_für_arrays}
\end{code}

% die Sache mit dem erstetzen von ArryDecl durch PntrDecl

\newlineparagraph{Umsetzung von Call by Value für Structs}

\begin{code}
  \centering
  \numberedcodebox[minted language=c, minted options={highlightlines={8}}]{./code_examples/verbose_fun_call_by_value_struct.picoc}
  \caption{PicoC-Code für Call by Value für Structs}
  \label{code:picoc_code_für_call_by_value_für_structs}
\end{code}

% argmode für Struct Call by Value

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={15-19}}]{./code_examples/verbose_fun_call_by_value_struct.picoc_mon}
  \caption{PicoC-Mon Pass für Call by Value für Structs}
  \label{code:picoc_mon_pass_für_call_by_value_for_structs}
\end{code}

% hier könnte man anmerken, dass die Adressen unterschiedlich berechnet werden für Stack und Globale...

\begin{code}
  \centering
  \numberedcodebox[minted language=text, minted options={highlightlines={13-19}}]{./code_examples/verbose_fun_call_by_value_struct.reti_blocks}
  \caption{RETI-Block Pass für Call by Value für Structs}
  \label{code:reti_blocks_pass_für_call_by_value_for_structs}
\end{code}

% Struct wird wirklich kopiert durch speziellen Argmode

% \subsection{Umsetzung kleinerer Details}
% langen Sprüngen, großen Konstanten, Division durch 0
\section{Fehlermeldungen}
\subsection{Error Handler}
\subsection{Arten von Fehlermeldungen}
\subsubsection{Syntaxfehler}
\subsubsection{Laufzeitfehler}
% Fehlermeldung ist, wenn der Lexer (partielle Funktion) oder Parser nicht matcht
% Token und Nodes enthalten Position, im Transformer wird die Position von den Token auf die Nodes übertragen und auch die Symboltabelle speichert Position
